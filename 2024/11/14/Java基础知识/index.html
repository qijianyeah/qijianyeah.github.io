<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>笔记总结 | QiJian</title><meta name="author" content="QiJian"><meta name="copyright" content="QiJian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础Java数据类型在Java中的数据类型有四类八种 整数型：byte short int longbyte ：1字节，8位，  1 byte &#x3D; 8 bits， byte 的默认值 0  Short:  占用两个字节，也就是16位，1 short &#x3D; 2 byte &#x3D; 16 bits， 默认值 0； Int: 占用四个字节，32位，1 int &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记总结">
<meta property="og:url" content="https://qijianyeah.github.io/2024/11/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="QiJian">
<meta property="og:description" content="Java基础Java数据类型在Java中的数据类型有四类八种 整数型：byte short int longbyte ：1字节，8位，  1 byte &#x3D; 8 bits， byte 的默认值 0  Short:  占用两个字节，也就是16位，1 short &#x3D; 2 byte &#x3D; 16 bits， 默认值 0； Int: 占用四个字节，32位，1 int &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qijianyeah.github.io/img/avatar.png">
<meta property="article:published_time" content="2024-11-13T18:20:09.000Z">
<meta property="article:modified_time" content="2024-11-16T03:43:28.516Z">
<meta property="article:author" content="QiJian">
<meta property="article:tag" content="java 知识总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qijianyeah.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qijianyeah.github.io/2024/11/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '笔记总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-sitemap"></i><span> 站点</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493"><i class="fa-fw fa fa-paper-plane"></i><span> 我的导航</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://bimg.cc"><i class="fa-fw iconfont icon-Bing"></i><span> 必应壁纸</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-bookmark"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-share-alt-square"></i><span> 分享</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493"><i class="fa-fw fa fa-train"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493"><i class="fa-fw fa fa-circle"></i><span> 虫洞</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">QiJian</span></a><a class="nav-page-title" href="/"><span class="site-name">笔记总结</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-sitemap"></i><span> 站点</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493"><i class="fa-fw fa fa-paper-plane"></i><span> 我的导航</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://bimg.cc"><i class="fa-fw iconfont icon-Bing"></i><span> 必应壁纸</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-bookmark"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-share-alt-square"></i><span> 分享</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493"><i class="fa-fw fa fa-train"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493"><i class="fa-fw fa fa-circle"></i><span> 虫洞</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">笔记总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-13T18:20:09.000Z" title="发表于 2024-11-14 02:20:09">2024-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-16T03:43:28.516Z" title="更新于 2024-11-16 11:43:28">2024-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java-%E5%9F%BA%E7%A1%80/">java 基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java-%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95/">java 基础 面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><p>在Java中的数据类型有四类八种</p>
<h3 id="整数型：byte-short-int-long"><a href="#整数型：byte-short-int-long" class="headerlink" title="整数型：byte short int long"></a>整数型：byte short int long</h3><p>byte ：1字节，8位，  1 byte &#x3D; 8 bits， byte 的默认值 0 </p>
<p>Short:  占用两个字节，也就是16位，1 short &#x3D; 2 byte &#x3D; 16 bits， 默认值 0；</p>
<p>Int: 占用四个字节，32位，1 int &#x3D; 32 bits，默认0；</p>
<p>long : 占用八字节，64位 ， 1 long &#x3D; 64 bits , 默认0L；</p>
<p>占用字节空间的大小： long &gt; int &gt; short &gt; byte</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型有两种数据类型：float 和 double</p>
<p>float：单精度浮点型，占用4位，1float &#x3D; 32bits , 默认0.01f;</p>
<p>Double:双精度浮点型，占用8位，1 double &#x3D; 64 bits ，默认值 0.0d；</p>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p> char: char类型是一个单一的  16 的 <code>Unicode</code>·字符， 最小值是**&#x3D;&#x3D;<code>\u0000</code> ( 值为0 )&#x3D;&#x3D;**，最大值是&#x3D;&#x3D;<code>\uffff</code> ( 值为65535)&#x3D;&#x3D;，char类型可以存储任何字符，例如char a &#x3D; ‘A’.</p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>boolean ： boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p>
<p>注意：上面的位数代表的是内存中的占用。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位数</th>
<th align="left">范围</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">8</td>
<td align="left">-2<sup>7</sup> ~ 2<sup>7</sup> - 1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">16</td>
<td align="left">\u0000 ~ \uffff</td>
<td align="left">‘u0000’</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">16</td>
<td align="left">-2<sup>15</sup> ~ 2<sup>15</sup> - 1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">32</td>
<td align="left">-2<sup>31</sup> ~ 2<sup>31</sup> - 1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">32</td>
<td align="left">-2<sup>31</sup> ~ 2<sup>31</sup> - 1</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">64</td>
<td align="left">-2<sup>63</sup> ~ 2<sup>63</sup> - 1</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">64</td>
<td align="left">-2<sup>63</sup> ~ 2<sup>63</sup> - 1</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">~</td>
<td align="left">~</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>装箱：将基本类型用它们对应的引用类型包装起来；</p>
<p>拆箱：将包装类型转换为基本数据类型；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 20; // 装箱    自动装箱就是jdk自己自动帮我们完成了Integer.valueOf()方法的调用</span><br><span class="line">int y = x;      // 拆箱		 自动拆箱就是jdk自动帮我们调用了IntValue()方法</span><br></pre></td></tr></table></figure>

<p>Integer的值在-128到127时，Integer对象是在IntegerCache.cache产生，会复用已有对象，也就是说，这个区间的Integer可以直接用等号进行判断。<br>Integer的值在-128到127之外时，Integer对象在堆上产生，不会复用已有对象，用等号会返回false</p>
<p>扩展：</p>
<p>缓存，以支持 JLS 要求的 -128 和 127（含）之间的值的自动装箱的对象标识语义。缓存在首次使用时初始化。缓存的大小可以通过 -XX：AutoBoxCacheMax&#x3D; 选项进行控制<size>。在虚拟机初始化期间，可以在 sun.misc.VM 类的专用系统属性中设置并保存 java.lang.Integer.IntegerCache.high 属性。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43663493/article/details/118943794?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171666010516800197012449%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=171666010516800197012449&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-118943794-null-null.nonecase&utm_term=%E8%A3%85%E7%AE%B1&spm=1018.2226.3001.4450">自动装箱与自动拆箱</a></p>
<h2 id="String-、-StringBuffer、StringBuilder-的区别"><a href="#String-、-StringBuffer、StringBuilder-的区别" class="headerlink" title="String 、 StringBuffer、StringBuilder 的区别"></a>String 、 StringBuffer、StringBuilder 的区别</h2><p>String 被声明为 final，因此它不可被继承。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。</p>
<p>在 Java 8 中，String 内部使用 <code>char</code> 数组存储数据。</p>
<p>Java 9 之后，String 类的实现改用 <code>byte</code> 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，<code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串 char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    AbstractStringBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>String, StringBuffer and StringBuilder</strong></p>
<ul>
<li>String 不可变是线程安全的</li>
<li>StringBuffer 和 StringBuilder 可变， StringBuilder 不是线程安全的， StringBuffer 是线程安全的，内部使用 <code>synchronized</code> 进行同步</li>
</ul>
<h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”) ?"></a>new String(“abc”) ?</h3><p>使用这种方式一共会创建两个字符串对象（前提是 <code>String Pool</code> 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，编译时期会在 <code>String Pool</code> 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>使用 new 的方式会在 <code>堆</code> 中创建一个字符串对象</li>
</ul>
<h3 id="String-的几种拼接方式区"><a href="#String-的几种拼接方式区" class="headerlink" title="String 的几种拼接方式区"></a>String 的几种拼接方式区</h3><h4 id="使用-拼接字符串"><a href="#使用-拼接字符串" class="headerlink" title="使用 + 拼接字符串"></a><strong>使用 <code>+</code> 拼接字符串</strong></h4><p><strong>其实只是Java提供的一个语法糖</strong></p>
<p>原理：字符串常量在拼接过程中，将 String 转成了 StringBuilder 后，使用其 append 方法进行处理的</p>
<h4 id="使用concat"><a href="#使用concat" class="headerlink" title="使用concat:"></a>使用<strong>concat</strong>:</h4><p>先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的 String 对象并返回.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>&#x3D;&#x3D;算术运算符优先级较高，关系和逻辑运算符优先级较低&#x3D;&#x3D;。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性。</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">运算符</th>
<th align="left">结核性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">() 、[] 、{}</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">!、 +、 -、 ~、 ++、 –</td>
<td align="left">从右往左</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">*、 &#x2F;、 %</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">+、 -</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">&lt;&lt;、 &gt;&gt;、 &gt;&gt;&gt;</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">&lt;、 &lt;&#x3D;、 &gt;、 &gt;&#x3D;、 instanceof</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">&#x3D;&#x3D;、 !&#x3D;</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">&amp;</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">^</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">|</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">||</td>
<td align="left">从左往右</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">?:</td>
<td align="left">从右往左</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">&#x3D;、 +&#x3D;、 -&#x3D;、 *&#x3D;、 &#x2F;&#x3D;、 &amp;&#x3D;、 |&#x3D;、 ^&#x3D;、 ~&#x3D;、 &lt;&lt;&#x3D;、 &gt;&gt;&#x3D;、  &gt;&gt;&gt;&#x3D;</td>
<td align="left">从右往左</td>
</tr>
</tbody></table>
<h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重载： 发生在同一个类中，&#x3D;&#x3D;方法名必须相同，参数类型不同、个数不同、顺序不同&#x3D;&#x3D;</p>
<p>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类.</p>
<p>哪些方法不可以被重写：final 方法、<strong>静态方法</strong>、private 不可见方法</p>
<p>对象的多态性：</p>
<ul>
<li>子类如果重写了父类的方法，通过子类对象调用的不一定是子类重写过的代码</li>
<li>非静态方法默认的调用对象是 this</li>
<li>this 对象在构造器或者说 <code>&lt;init&gt;</code> 方法中就是在还能够在创建的对象</li>
</ul>
<h3 id="Object-类通用方法"><a href="#Object-类通用方法" class="headerlink" title="Object 类通用方法"></a>Object 类通用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//返回当前运行时对象的Class对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">//返回对象的哈希码，主要使用在哈希表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> <span class="comment">//用于比较 2 个对象的内存地址是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//创建并返回当前对象的一份拷贝。对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span><span class="comment">//唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span><span class="comment">//唤醒在此对象监视器上等待的所有线程，而不是一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，表示额外时间(毫秒)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

<h2 id="与-equals"><a href="#与-equals" class="headerlink" title="&#x3D;&#x3D; 与 equals"></a>&#x3D;&#x3D; 与 equals</h2><p>&#x3D;&#x3D; : 基本数据类型比较的是值，引用数据类型比较的是内存地址</p>
<p>equals : 判断两个对象是否相等</p>
<p><strong>注意：</strong></p>
<ul>
<li>String 重写 equals 方法，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值</li>
<li>在自定义类重写 equals 方法必须重写 hashCode 方法</li>
<li>hashCode() 相等是两个对象相等的必要不充分条件</li>
<li>equals 相等是两个对象相等的必要条件</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul>
<li>浅拷贝：拷贝对象与原对象的引用时同一个对象</li>
<li>深拷贝：拷贝对象与原对象的引用为不同对象</li>
</ul>
<h3 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h3><p><strong>基本数据类型</strong>：传递数据值</p>
<p><strong>引用类型</strong>：传递地址值</p>
<p><strong>特殊类型</strong>：String、包装类等对象的不可变性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    change(i, str, num, arr, t);</span><br><span class="line"></span><br><span class="line">    System.out.println(i); <span class="comment">// 1</span></span><br><span class="line">    System.out.println(str); <span class="comment">// hello</span></span><br><span class="line">    System.out.println(num); <span class="comment">// 200</span></span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">// [2,3,3]</span></span><br><span class="line">    System.out.println(t.a); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> j, String s, Integer n, <span class="type">int</span>[] a, Test t)</span>&#123;</span><br><span class="line">    j += <span class="number">1</span>;</span><br><span class="line">    s += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">    t.a += <span class="number">1</span>; <span class="comment">// 修改的是对象的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul>
<li>类 ： 类不能被继承，所有成员方法都会被隐式地指定为final方法</li>
<li>变量 : 基本数据类型变量初始化之后便不能更改；引用类型的变量初始化之后便不能再让其指向另一个对象</li>
<li>方法 ： 方法锁定，禁止被继承类重写</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>初始化顺序：<strong>静态变量和静态语句块优先于实例变量和普通语句块</strong>，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><ul>
<li>一个类要创建实例需要先加载并初始化该类<ul>
<li>main 方法所在的类需要先加载和初始化</li>
</ul>
</li>
<li>一个子类要初始化需要先初始化父类</li>
<li>一个类初始化就是执行 <code>&lt;clinit&gt;</code> 方法<ul>
<li><clinit>&#96; 方法由静态类变量显示赋值代码和静态代码块组成</li>
<li>类变量显示赋值代码和静态代码块从上到下顺序执行</li>
<li><code>&lt;clinit&gt;</code> 方法只执行一次</li>
</ul>
</li>
</ul>
<h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><ul>
<li>实例初始化就是执行<code>&lt;init&gt;</code>方法<ul>
<li><code>&lt;init&gt;</code> 方法可能重载有多个有几个构造器就有几个<code>&lt;init&gt;</code>方法</li>
<li><code>&lt;init&gt;</code> 方法由非静态实例变量显示赋值代码和非静态代码块、对应狗在其代码组成</li>
<li>非静态实例变量显示赋值代码和非静态代码块从上到下执行，构造器代码最后执行</li>
<li>每次创建实例对象调用对象的构造器，执行对应的<code>&lt;init&gt;</code> 方法</li>
</ul>
</li>
</ul>
<h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> in.nextLine();</span><br><span class="line">in.close();</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine();</span><br></pre></td></tr></table></figure>





<h1 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h1><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<ul>
<li>Set<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说 使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li>
</ul>
</li>
<li>List<ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，线程安全。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
</li>
<li>Queue<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
</li>
</ul>
<h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h2 id="面试问题："><a href="#面试问题：" class="headerlink" title="面试问题："></a>面试问题：</h2><p>1、在一个静态方法内调用一个非静态成员为什么是非法的?</p>
<p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<p>2、在 Java 中定义一个不做事且没有参数的构造方法的作用？</p>
<p>Java 程序在执行子类的构造方法之前，&#x3D;&#x3D;如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中无参构造方法&#x3D;&#x3D;。如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误。</p>
<p>3、抽象类与接口的区别</p>
<ul>
<li>接口的方法默认是 <code>public</code> , 所有方法在接口中不能有实现（JDK 8 接口允许有默认实现，静态方法）；抽象类可以有非抽象方法</li>
<li>接口中实例变量默认为 final 类型；抽象类不一定</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类</li>
<li>一个类实现接口需要实现接口中的所有方法</li>
<li>&#x3D;&#x3D;接口不能用 new 实例化，但可以声明&#x3D;&#x3D;</li>
</ul>
<p>4、为什么 Java 中只有值传递？</p>
<ul>
<li>按值调用(call by value)表示方法接收的是调用者提供的值。</li>
<li>按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。</li>
</ul>
<p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<p><strong>Java 程序设计语言总是采用按值调用。方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p>5、Java 序列化中如果有些字段不想进行序列化，怎么办？</p>
<p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><h1 id="Java“锁”"><a href="#Java“锁”" class="headerlink" title="Java“锁”"></a>Java“锁”</h1><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><p>悲观锁：&#x3D;&#x3D;认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。&#x3D;&#x3D;synchronized关键字和Lock的实现类都是悲观锁。适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=============悲观锁的调用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//加锁后的业务逻辑......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">lock.lock();...</span><br></pre></td></tr></table></figure>

<p>乐观锁:&#x3D;&#x3D;乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入&#x3D;&#x3D;。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再抢。</p>
<p>乐观锁一般有两种实现方式：1、采用版本号机制。2、CAS（Compare-and-Swap，即比较并替换）算法实现。</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>何为公平锁&#x2F;非公平锁?t</p>
<p>⽣活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//默认false用的是非公平锁，分配的平均一点，=--》公平一点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Object objectLock = new Object();</span></span><br><span class="line"><span class="comment">    public void sale()&#123;</span></span><br><span class="line"><span class="comment">        synchronized (objectLock) &#123;</span></span><br><span class="line"><span class="comment">            if(number &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(Thread.currentThread().getName()+&quot;\t 卖出第: &quot;+(number--)+&quot;\t 还剩下: &quot;+number);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;d&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;e&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</strong></p>
<p>1、恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</p>
<p>2、使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</p>
<p><strong>使⽤公平锁会有什么问题？</strong></p>
<p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”。</p>
<p><strong>什么时候用公平？什么时候用非公平？</strong></p>
<p>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；否则那就用公平锁，大家公平使用。</p>
<h2 id="可重入锁-又名递归锁"><a href="#可重入锁-又名递归锁" class="headerlink" title="可重入锁(又名递归锁)"></a>可重入锁(又名递归锁)</h2><p>​	可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p>
<p>​	如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。所以Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<h3 id="可重入锁种类"><a href="#可重入锁种类" class="headerlink" title="可重入锁种类"></a>可重入锁种类</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁。</p>
<p>隐式锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。<br>简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</p>
<h5 id="同步快"><a href="#同步快" class="headerlink" title="同步快"></a>同步快</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;<span class="comment">// lock</span></span><br><span class="line">            System.out.println(<span class="string">&quot;-----外层&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----中层&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----内层&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//unlock</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用并且不发生死锁，这样的锁就叫做可重入锁。</span></span><br><span class="line"><span class="comment"> * 简单的来说就是：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Synchronized的重入的实现机理"><a href="#Synchronized的重入的实现机理" class="headerlink" title="Synchronized的重入的实现机理"></a>Synchronized的重入的实现机理</h4><p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p>
<p>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>
<p>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p>
<p>为什么任何一个对象都可以成为一个锁？</p>
<p>在Java中，任何一个对象都可以成为一个锁是因为Java的内置同步机制是基于每个对象的监视器（monitor）实现的。监视器是一种同步工具，可以用来协调多个线程对同一个对象的访问。</p>
<h4 id="显式锁（即Lock）"><a href="#显式锁（即Lock）" class="headerlink" title="显式锁（即Lock）"></a>显式锁（即Lock）</h4><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----外层&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------22222&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁及排查"><a href="#死锁及排查" class="headerlink" title="死锁及排查"></a>死锁及排查</h2><p>​	死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p>产生死锁主要原因:</p>
<ol>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ol>
<p>死锁案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有A锁，期待获得B锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得B锁成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有B锁，期待获得A锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得A锁成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何排查死锁</p>
<p>纯命令: 1、jps -l ；2、jstack 进程编号；</p>
<p>图形化：jconsole</p>
<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h2><p>1、进程：是程序的⼀次执⾏，是&#x3D;&#x3D;系统进⾏资源分配和调度的独⽴单位&#x3D;&#x3D;，每⼀个进程都有它⾃⼰的内存空间和系统资源。</p>
<p>2、线程：在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程，⼀个进程会有1个或多个线程。</p>
<p>3、管程：即Monitor(监视器)，也就是我们平时所说的锁。</p>
<p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p>
<p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    </span><br><span class="line">  <span class="keyword">synchronized</span> (o)    &#123;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p>
<p>4、用户线程和守护线程</p>
<p>Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程。</p>
<p>守护线程：是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程。</p>
<p>用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.itdachang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 开始运行，&quot;</span>+(Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span>:<span class="string">&quot;用户线程&quot;</span>));        </span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);    </span><br><span class="line">    <span class="comment">//线程的daemon属性为true表示是守护线程，false表示是用户线程    </span></span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);    </span><br><span class="line">    t1.start();    </span><br><span class="line">    <span class="comment">//3秒钟后主线程再运行    </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">      e.printStackTrace(); </span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">&quot;----------main线程运行完毕&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出。如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以&#x3D;&#x3D;当系统只剩下守护进程的时候，java虚拟机会自动退出&#x3D;&#x3D;。设置守护线程，需要在start()方法之前进行。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>方式一：<strong>使用 Thread类或继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>方式二：<strong>实现 Runnable 接口配合Thread</strong></p>
<p>把【线程】和【任务】（要执行的代码）分开</p>
<ul>
<li>Thread 代表线程</li>
<li>Runnable 可运行的任务（线程要执行的代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start(); </span><br></pre></td></tr></table></figure>

<p><strong>方式3：使用有返回值的 Callable</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>()); </span><br></pre></td></tr></table></figure>

<p>方式4:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">  () -&gt; System.out.println(Thread.currentThread().getName())</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法.</p>
</blockquote>
<h3 id="线程启动和停止"><a href="#线程启动和停止" class="headerlink" title="线程启动和停止"></a>线程启动和停止</h3><p>线程启动：调用start方法</p>
<p>线程停止：调用stop方法</p>
<p>注意：线程自带的stop方法，一方面已经过时，另一方面，&#x3D;&#x3D;不会对停止的线程做状态保存，使得线程中涉及的对象处于未知状态&#x3D;&#x3D;，如果这些状态，其他线程也会使用，将会使得其他线程出现无法预料的异常，所以，停止程序的功能，需要自己实现。</p>
<h3 id="线程暂停和中断"><a href="#线程暂停和中断" class="headerlink" title="线程暂停和中断"></a>线程暂停和中断</h3><p>暂停:Java中线程的暂停是调用 java.lang.Thread 类的 sleep 方法。该方法会使当前正在执行的线程暂停,指定的一段时间，如果线程持有锁，&#x3D;&#x3D;sleep 方法结束前并不会释放该锁&#x3D;&#x3D;。</p>
<p>中断: interrupt 方法，该方法直接对线程调用。&#x3D;&#x3D;当被interrupt的线程正在sleep或wait时，会抛出 InterruptedException 异常&#x3D;&#x3D;。interrupt 方法只是改变目标线程的中断状态（interrupt status），而那些会抛出InterruptedException 异常的方法，如wait、sleep、join等，都是在方法内部不断地检查中断状态的值。</p>
<ul>
<li><p>interrupt方法</p>
<p>Thread实例方法：必须由其它线程获取被调用线程的实例后，进行调用。实际上，只是改变了被调用线程的内部中断状态；</p>
</li>
<li><p>Thread.interrupted方法</p>
<p>Thread类方法：必须在当前执行线程内调用，该方法返回当前线程的内部中断状态，然后清除中断状态（置为false） ；</p>
</li>
<li><p>isInterrupted方法</p>
<p>Thread实例方法：用来检查指定线程的中断状态。当线程为中断状态时，会返回true；否则返回false。</p>
</li>
</ul>
<p>interrupt() ：</p>
<ul>
<li>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；</li>
<li>如果线程处于sleep, wait, join 等状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；</li>
<li>如果线程处于I&#x2F;O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常；</li>
<li>如果线程在Selector上被阻塞，select方法将立即返回；</li>
<li>如果非以上情况，将直接标记 interrupt 状态；</li>
</ul>
<p>注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的线程，不会受 interrupt 中断；</p>
<p>阻塞情况下中断，抛出异常后线程恢复非中断状态，即 interrupted &#x3D; false</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java线程可能的状态：</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="image-20240527003435340"></p>
<p>线程的状态变迁</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="image-20240526212126155"></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>
</ul>
<h3 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h3><p>提高cpu的利用率：在等待磁盘IO，网络IO或者等待用户输入时，CPU可以同时去处理其他任务。</p>
<p>更高效的响应：多线程使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态，不会造成无法响应的现象。</p>
<p>公平使用CPU资源：当前没有进行处理的任务，可以将处理器时间让给其它任务;占用大量处理时间的任务，也可以定期将处理器时间让给其它任务;通过对CPU时间的划分，使得CPU时间片可以在多个线程之间切换，避免需要长时间处理的线程独占CPU，导致其它线程长时间等待。</p>
<h3 id="多线程的代价"><a href="#多线程的代价" class="headerlink" title="多线程的代价"></a>多线程的代价</h3><p>更复杂的设计</p>
<p>​	共享数据的读取，数据的安全性，线程之间的交互，线程的同步等；</p>
<p>上下文环境切换</p>
<p>​	线程切换，cpu需要保存本地数据、程序指针等内容；</p>
<p>更多的资源消耗</p>
<p>​	每个线程都需要内存维护自己的本地栈信息，操作系统也需要资源对线程进行管理维护；</p>
<h2 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>​	&#x3D;&#x3D;临界资源是一次仅允许一个进程使用的共享资源。&#x3D;&#x3D;<strong>各进程采取互斥的方式，实现共享的资源称作临界资源。</strong>属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="comment">// 临界资源</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 临界区  （在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制。）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = <span class="built_in">this</span>.count + value;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>何谓竞态条件</strong></p>
<p>​	当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
<p>​	导致竞态条件发生的代码区称作临界区。</p>
<p>​	在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制。</p>
<p><strong>何谓线程安全</strong></p>
<p>​	允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。</p>
<h3 id="对象的安全"><a href="#对象的安全" class="headerlink" title="对象的安全"></a>对象的安全</h3><h4 id="局部基本类型变量"><a href="#局部基本类型变量" class="headerlink" title="局部基本类型变量"></a>局部基本类型变量</h4><p>&#x3D;&#x3D;局部变量存储在线程自己的栈中。&#x3D;&#x3D;也就是说，局部变量永远也不会被多个线程共享（只是更新当前线程栈的值，不会影响其他线程，也就是不共享数据）。所以，基础类型的局部变量是线程安全的。</p>
<h4 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h4><p>对象的局部引用和基础类型的局部变量不太一样，尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。</p>
<p>如果在某个方法中创建的对象不会逃逸出（即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。</p>
<p>实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 该对象不会逃逸出</span></span><br><span class="line">	<span class="type">LocalObject</span> <span class="variable">localObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalObject</span>();</span><br><span class="line">	localObject.callMethod();</span><br><span class="line">	method2(localObject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(LocalObject localObject)</span>&#123;</span><br><span class="line">	localObject.setValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象成员-成员变量"><a href="#对象成员-成员变量" class="headerlink" title="对象成员(成员变量)"></a>对象成员(成员变量)</h3><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NotThreadSafe</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotThreadSafe</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(sharedInstance)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(sharedInstance)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">NotThreadSafe</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(NotThreadSafe instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance.add(<span class="string">&quot; &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.instance.builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotThreadSafe</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。</p>
<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableValue</span>&#123;</span><br><span class="line">  <span class="comment">// 创建的该属性不可变（没有set方法）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ImmutableValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImmutableValue类的成员变量 value 是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建， value 变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/JMM.png" alt="image-20240527015028358"></p>
<p>线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<h2 id="CAS乐观锁"><a href="#CAS乐观锁" class="headerlink" title="CAS乐观锁"></a>CAS乐观锁</h2><p>乐观锁：不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。其实现方式有一种比较典型的就是Compare and Swap( CAS )。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<p>1.在内存地址V当中，存储着值为10的变量。</p>
<p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270159880.png" alt="image-20240527015919145"></p>
<p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270159406.png" alt="image-20240527015941075"></p>
<p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270201086.png" alt="image-20240527020130548"></p>
<p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A&#x3D;11，B&#x3D;12。这个重新尝试的过程被称为自旋。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270203433.png" alt="image-20240527020313272"></p>
<p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270205946.png" alt="image-20240527020529111"></p>
<p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270206835.png" alt="image-20240527020630202"></p>
<p>Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>CAS的缺点：</p>
<p>1.CPU开销较大</p>
<p>​	在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>
<p>2.不能保证代码块的原子性</p>
<p>​	CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p>
<h2 id="Synchronized块"><a href="#Synchronized块" class="headerlink" title="Synchronized块"></a>Synchronized块</h2><p>Java中的同步块用&#x3D;&#x3D;synchronized标记&#x3D;&#x3D;。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p>
<h3 id="同步块的分类："><a href="#同步块的分类：" class="headerlink" title="同步块的分类："></a>同步块的分类：</h3><ol>
<li><p>实例方法的同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法声明中同步（synchronized ）关键字。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java实例方法同步是&#x3D;&#x3D;同步在拥有该方法的对象上&#x3D;&#x3D;。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。</p>
</li>
<li><p>静态方法的同步</p>
<p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法的同步是指&#x3D;&#x3D;同步在该方法所在的类对象上&#x3D;&#x3D;。因为在Java虚拟机中<strong>一个类只能对应一个类对象</strong>，所以同时只允许一个线程执行同一个类中的静态同步方法。</p>
<p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
</li>
<li><p>实例方法中的同步块</p>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">		<span class="built_in">this</span>.count += value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为&#x3D;&#x3D;add方法的实例本身&#x3D;&#x3D;。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p>
<p>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。</p>
<p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">log1</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line">		log.writeln(msg1);</span><br><span class="line">		log.writeln(msg2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">			log.writeln(msg1);</span><br><span class="line">			log.writeln(msg2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。</p>
<p>&#x3D;&#x3D;如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。&#x3D;&#x3D;在 Java 中，<code>synchronized(this)</code> 确实锁住了调用该方法的对象。锁定对象时，其他任何试图进入被同一对象锁定的 <code>synchronized</code> 方法或 <code>synchronized</code> 块的线程都会被阻塞，直到锁被释放。而试图进入该对象的非 <code>synchronized</code> 方法或非 <code>synchronized</code> 代码块的线程不会被阻塞，它们可以正常运行。</p>
</li>
<li><p>静态方法中的同步块</p>
</li>
</ol>
<p>同步在该方法所属的类对象上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">log1</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line">		log.writeln(msg1);</span><br><span class="line">		log.writeln(msg2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(MyClass.class)&#123;</span><br><span class="line">			log.writeln(msg1);</span><br><span class="line">			log.writeln(msg2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法不允许同时被线程访问。</p>
<p>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p>
<h3 id="Synchronized锁的存储"><a href="#Synchronized锁的存储" class="headerlink" title="Synchronized锁的存储"></a>Synchronized锁的存储</h3><p>​	synchronized用的&#x3D;&#x3D;锁存储在Java对象头&#x3D;&#x3D;，如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头，32位虚拟机，1字宽等于4字节，即32位。</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><strong>对象的内存布局</strong></h4><p>Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<ul>
<li><p>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。</p>
</li>
<li><p>实例数据：存放类的属性数据信息，包括父类的属性信息；</p>
</li>
<li><p>对齐填充：由于虚拟机要求 <strong>对象起始地址必须是8字节的整数倍</strong>。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282137739.png" alt="img"></p>
</li>
</ul>
<h5 id="对象头详解"><a href="#对象头详解" class="headerlink" title="对象头详解"></a><strong>对象头详解</strong></h5><p>HotSpot虚拟机的对象头包括：</p>
<ul>
<li>Mark Word</li>
</ul>
<p>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（4位（与分代年龄有关））、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。</p>
<ul>
<li>Klass Pointer</li>
</ul>
<p>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 32位4字节，64位开启指针压缩或最大堆内存&lt;32g时4字节，否则8字节。jdk1.8默认开启指针压缩后为4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。</p>
<ul>
<li>数组长度（只有数组对象有）</li>
</ul>
<p>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度。 4字节</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270252460.png" alt="image-20240527025211529"></p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282136832.png" alt="image.png"></p>
<h5 id="Mark-Word的结构"><a href="#Mark-Word的结构" class="headerlink" title="Mark Word的结构"></a><strong>Mark Word的结构</strong></h5><p><strong>32位JVM下的对象结构描述</strong></p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282147663.png" alt="image.png"></p>
<p><strong>64位JVM下的对象结构描述</strong></p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282147130.png" alt="image.png"></p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>​	程序不会有锁的竞争</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h5 id="偏向锁的获取流程："><a href="#偏向锁的获取流程：" class="headerlink" title="偏向锁的获取流程："></a>偏向锁的获取流程：</h5><p> （1）查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态。</p>
<p> （2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，若相同，表示线程已经获得了锁，如果不同，则进入（3）</p>
<p> （3）测试Mark Word的偏向锁的标识是否设置为1，如果没有设置，则使用&#x3D;&#x3D;CAS操作竞争锁&#x3D;&#x3D;，如果设置了，则尝试使用CAS尝试将Mark Word中线程ID设置为当前线程ID，如果尝试失败，则执行（4）</p>
<p> （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。当到达&#x3D;&#x3D;全局安全点（在这个时间点，没有正在执行的代码）&#x3D;&#x3D;时之前获得偏向锁的线程被挂起，&#x3D;&#x3D;偏向锁升级为轻量级锁&#x3D;&#x3D;，然后被阻塞在安全点的线程继续往下执行同步代码。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282207782.png" alt="image-20240528220750790"></p>
<h5 id="偏向锁JVM命令"><a href="#偏向锁JVM命令" class="headerlink" title="偏向锁JVM命令"></a>偏向锁JVM命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial |grep BiasedLock*</span><br><span class="line">-XX:+UseBiasedLocking：启用偏向锁定，这是 JVM 的默认设置。</span><br><span class="line">-XX:-UseBiasedLocking：禁用偏向锁定，所有锁将直接使用轻量级或重量级锁。</span><br><span class="line"></span><br><span class="line">例如：java -XX:-UseBiasedLocking -jar YourApplication.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282213888.png" alt="image-20240528221322470"></p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁</p>
<p>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282226235.png" alt="po_diagram (1)"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>​	轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。</p>
<p>轻量级锁的加锁过程：</p>
<p>（1）<strong>当线程执行代码进入同步块时，若Mark Word为无锁状态，虚拟机先在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储当前对象的Mark Word的拷贝</strong>，官方称之为“Dispalced Mark Word”，此时状态如下图：</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270255844.png" alt="image-20240527025457987"></p>
<p>（2）复制对象头中的Mark Word到锁记录中。</p>
<p>（3）复制成功后，虚拟机将用CAS操作将对象的Mark Word更新为执行Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行4，否则执行5。</p>
<p>（4）如果更新成功，则这个线程拥有了这个锁，并将锁标志设为00，表示处于轻量级锁状态，此时状态图：</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270255717.png" alt="image-20240527025543187"></p>
<p>（5）如果更新失败，则说明有其他线程竞争锁，当前线程便通过自旋来获取锁。轻量级锁就会膨胀为重量级锁，Mark Word中存储重量级锁（互斥锁）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<h5 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h5><p>java6之前：默认启用，默认情况下自旋的次数是 10 次（-XX:PreBlockSpin&#x3D;10来修改）或者自旋线程数超过cpu核数一半。</p>
<p>Java6之后：自适应意味着自旋的次数不是固定不变的，而是根据：1.同一个锁上一次自旋的时间。2.拥有锁线程的状态来决定。</p>
<h5 id="轻量锁与偏向锁的区别和不同"><a href="#轻量锁与偏向锁的区别和不同" class="headerlink" title="轻量锁与偏向锁的区别和不同"></a>轻量锁与偏向锁的区别和不同</h5><ul>
<li>争夺轻量级锁失败时，自旋尝试抢占锁</li>
<li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li>
</ul>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>即当有其他线程占用锁时，当前线程会进入阻塞状态。（有大量的线程参与锁的竞争，冲突性很高）</p>
<h4 id="总结：锁对象状态转换"><a href="#总结：锁对象状态转换" class="headerlink" title="总结：锁对象状态转换"></a><strong>总结：锁对象状态转换</strong></h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282244810.png" alt="image-20240528224415233"></p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282224953.png" alt="po_diagram"></p>
<h2 id="关键字Volatile"><a href="#关键字Volatile" class="headerlink" title="关键字Volatile"></a>关键字Volatile</h2><h3 id="被volatile修改的变量有2大特点"><a href="#被volatile修改的变量有2大特点" class="headerlink" title="被volatile修改的变量有2大特点"></a>被volatile修改的变量有2大特点</h3><p>特点:  可见性 , 有序性</p>
<ul>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li><del>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性</del></li>
<li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性。</li>
</ul>
<h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值&#x3D;&#x3D;立即刷新回主内存中&#x3D;&#x3D;。</p>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，&#x3D;&#x3D;直接从主内存中读取共享变量&#x3D;&#x3D;</p>
<p><strong>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</strong></p>
<h3 id="内存屏障-面试重点必须拿下"><a href="#内存屏障-面试重点必须拿下" class="headerlink" title="内存屏障(面试重点必须拿下)"></a>内存屏障(面试重点必须拿下)</h3><blockquote>
<p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p>
<p>内存屏障之前的所有写操作都要回写到主内存，内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p>
<p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。<br>一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。</p>
</blockquote>
<h4 id="保证可见性和有序性"><a href="#保证可见性和有序性" class="headerlink" title="保证可见性和有序性"></a>保证可见性和有序性</h4><ol>
<li><strong>可见性</strong>：当一个线程修改了 <code>volatile</code> 变量的值，新值对于其他所有线程立即可见。</li>
<li><strong>禁止指令重排序</strong>：对 <code>volatile</code> 变量的读写操作不会被指令重排序，因此 <code>volatile</code> 变量的操作在内存中是有序的。</li>
</ol>
<p><strong>volatile重排序规则</strong>:</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202406011435088.png" alt="image-20240601143456443"></p>
<h4 id="volatile-不能保证原子性的原因"><a href="#volatile-不能保证原子性的原因" class="headerlink" title="volatile 不能保证原子性的原因"></a><code>volatile</code> 不能保证原子性的原因</h4><p>尽管 <code>volatile</code> 能确保变量的可见性和有序性，但它不能保证对变量的复合操作（例如读取-修改-写入）是原子的。例如，考虑以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 在多个线程中执行</span></span><br><span class="line">count++;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>count++</code> 操作实际上分为三步：</p>
<ol>
<li>读取 <code>count</code> 的当前值。</li>
<li>将值加 1。</li>
<li>将新值写回 <code>count</code>。</li>
</ol>
<p>即使 <code>count</code> 是 <code>volatile</code> 的，其他线程可能会在步骤 1 和步骤 3 之间修改 <code>count</code> 的值，从而导致竞争条件和数据不一致的问题。因此，<code>count++</code> 不是一个原子操作。</p>
<h4 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282343216.png" alt="po_diagram"></p>
<p>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。<br>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。<br>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</p>
<h4 id="JMM-就将内存屏障插⼊策略分为-4-种"><a href="#JMM-就将内存屏障插⼊策略分为-4-种" class="headerlink" title="JMM 就将内存屏障插⼊策略分为 4 种"></a>JMM 就将内存屏障插⼊策略分为 4 种</h4><ol>
<li><p>在每个 volatile <strong>写</strong>操作的前⾯插⼊⼀个 StoreStore 屏障</p>
</li>
<li><p>在每个 volatile <strong>写</strong>操作的后⾯插⼊⼀个 StoreLoad 屏障</p>
</li>
<li><p>在每个 volatile <strong>读</strong>操作的后⾯插⼊⼀个 LoadLoad 屏障</p>
</li>
<li><p>在每个 volatile <strong>读</strong>操作的后⾯插⼊⼀个 LoadStore 屏障</p>
</li>
</ol>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282345615.png" alt="po_diagram (1)"></p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202406011436972.png" alt="image-20240601143620894"></p>
<h3 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h3><h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><p>说明：保证不同线程对这个变量进行操作时的可见性，即变量一旦改变所有线程立即可见。</p>
<h4 id="volatile变量的读写过程"><a href="#volatile变量的读写过程" class="headerlink" title="volatile变量的读写过程"></a>volatile变量的读写过程</h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282349584.png" alt="po_diagram (2)"></p>
<ol>
<li>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</li>
<li>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</li>
<li>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li>
<li>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</li>
<li>store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存</li>
<li>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</li>
<li>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁 ，所以，JVM提供了另外两个原子指令：</li>
<li>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</li>
<li>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</li>
</ol>
<h4 id="没有原子性"><a href="#没有原子性" class="headerlink" title="没有原子性"></a><span style="color: red;">没有原子性</span></h4><blockquote>
<p>volatile变量的复合操作(如i++)不具有原子性</p>
</blockquote>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282352674.png" alt="po_diagram"></p>
<p>⚠️：数据加载、数据计算、数据赋值不是原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span> &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileNoAtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myNumber.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + myNumber.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从i++的字节码角度说明：</p>
<p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>public void add(){<br>        i++; &#x2F;&#x2F;不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成<br> }<br>如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于add方法必须使用synchronized修饰，以便保证线程安全.</p>
<p>不保证原子性：多线程环境下，”数据计算”和”数据赋值”操作可能多次出现，即操作非原子。若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致 ；对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。<br>由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步</p>
<p>读取赋值一个普通变量的情况：</p>
<p>当线程1对主内存对象发起read操作到write操作第一套流程的时间里，线程2随时都有可能对这个主内存对象发起第二套操作。</p>
<p>既然一修改就是可见，为什么还不能保证原子性？</p>
<p>volatile主要是对其中部分指令做了处理</p>
<p>要use(使用)一个变量的时候必需load(载入），要载入的时候必需从主内存read(读取）这样就解决了读的可见性。 </p>
<p>写操作是把assign和store做了关联(在assign(赋值)后必需store(存储))。store(存储)后write(写入)。也就是做到了给一个变量赋值的时候一串关联指令直接把变量值写到主内存。就这样通过用的时候直接从主内存取，在赋值到直接写回主内存做到了内存可见性。o(╥﹏╥)o</p>
<p> <strong>read-load-use</strong> 和 <strong>assign-store-write</strong> 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次…o(╥﹏╥)o<br>但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i &#x3D; i + 1; i++;之类的，那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。《深入理解Java虚拟机》提到：</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290032234.png" alt="po_diagram (1)"></p>
<p>JVM的字节码，i++分成三步，间隙期不同步非原子操作(i++)</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290036054.png" alt="po_diagram (2)"></p>
<h3 id="指令禁重排"><a href="#指令禁重排" class="headerlink" title="指令禁重排"></a>指令禁重排</h3><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>​	&#x3D;&#x3D;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段&#x3D;&#x3D;，有时候会改变程序语句的先后顺序<br>不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序<br>注意⚠️：重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p>
<p>重排序的分类和执行流程</p>
<ol>
<li>编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</li>
<li>指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序： 由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li>
<li>数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</li>
</ol>
<p>案例 ：<br><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290042815.png" alt="image-20240529004156263"></p>
<p>存在数据依赖关系，禁止重排序&#x3D;&#x3D;&#x3D;&gt; 重排序发生，会导致程序运行结果不同。<br> 编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290050933.png" alt="image-20240529005028521"></p>
<h3 id="volatile的底层实现是通过内存屏障"><a href="#volatile的底层实现是通过内存屏障" class="headerlink" title="volatile的底层实现是通过内存屏障"></a>volatile的底层实现是通过内存屏障</h3><h4 id="volatile有关的禁止指令重排的行为"><a href="#volatile有关的禁止指令重排的行为" class="headerlink" title="volatile有关的禁止指令重排的行为"></a>volatile有关的禁止指令重排的行为</h4><ol>
<li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li>
<li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</li>
<li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</li>
</ol>
<h4 id="四大屏障的插入情况"><a href="#四大屏障的插入情况" class="headerlink" title="四大屏障的插入情况"></a>四大屏障的插入情况</h4><ol>
<li>在每一个volatile写操作前面插入一个StoreStore屏障，StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</li>
<li>在每一个volatile写操作后面插入一个StoreLoad屏障，StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序。</li>
<li>在每一个volatile读操作前面插入一个LoadLoad屏障，LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</li>
<li>在每一个volatile读操作后面插入一个LoadStore屏障，LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---i  =  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290058587.png" alt="image-20240529005803058"></p>
<h3 id="如何正确使用volatile"><a href="#如何正确使用volatile" class="headerlink" title="如何正确使用volatile"></a>如何正确使用volatile</h3><p>单一赋值可以，but含复合运算赋值不可以(i++之类)</p>
<p>volatile int a &#x3D; 10;  volatile boolean flag &#x3D; false;</p>
<p>1、状态标志，判断业务是否结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用：作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束 </span></span><br><span class="line"><span class="comment"> * 理由：状态标志并不依赖于程序内任何其他状态，且通常只有一种状态转换 </span></span><br><span class="line"><span class="comment"> * 例子：判断业务是否结束 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseVolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do something......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、开销较低的读，写锁策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseVolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用：当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销</span></span><br><span class="line"><span class="comment">     * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;   <span class="comment">//利用volatile保证读取操作的可见性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value++; <span class="comment">//利用synchronized保证复合操作的原子性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DCL双端锁的发布"><a href="#DCL双端锁的发布" class="headerlink" title="DCL双端锁的发布"></a>DCL双端锁的发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双重锁设计</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单线程环境下(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290127295.png" alt="image-20240529012737397"></p>
<p>解决01:加volatile修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过volatile声明，实现线程安全的延迟初始化。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SafeDoubleCheckSingleton singleton;</span><br></pre></td></tr></table></figure>

<p>解决02:采用静态内部类的方式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在比较好的做法就是采用静态内部内的方式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonDemoHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonDemoHandler.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h2><p>​	ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为&#x3D;&#x3D;每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。&#x3D;&#x3D;ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p>
<pre><code> 实现每一个线程都有自己专属的本地变量副本，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。
</code></pre>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302243032.png" alt="image-20240530224314824"></p>
<h2 id="api介绍"><a href="#api介绍" class="headerlink" title="api介绍"></a>api介绍</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>1、new 之后复写initiaValue()</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302305249.png" alt="image-20240530230508608"></p>
<p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p>
<p>2、ThreadLocal.withInitial(() - 0);</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302245537.png" alt="image-20240530224540542"></p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>​	返回此线程局部变量的当前线程副本中的值。如果变量对当前线程没有值，则首先将其初始化为initialValue方法调用返回的值。返回值:线程本地当前线程的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>设置值。<code>threadLocal.set(value);</code></p>
<p>将此线程局部变量的当前线程副本设置为指定值。大多数子类不需要重写这个方法，只依赖于{@link initialValue}方法来设置线程局部变量的值。</p>
<p>@param value要存储在当前线程的这个线程本地副本中的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>移除此线程局部变量的当前线程值。如果这个线程局部变量随后被当前线程{@linkplain get read}，它的值将通过调用它的{@link initialValue}方法重新初始化，除非当前线程在此期间将它的值设置为{@linkplain set set}。这可能导致在当前线程中多次调用{@code initialValue}方法。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302309010.png" alt="image-20240530230912717"></p>
<h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、每次使用日历控件都需要设置一次日期格式，刚入行的时候，经验不丰富。为了方便把sdf定义为一个静态变量，并且把它分装成了一个方法。后来其他同事相继调用，各种频繁调错。被测试痛批。</span></span><br><span class="line">    <span class="comment">//  源码：sdf中的日期格式是不同步的，推荐位每一个线程创建独立的格式实例。如果多个线程同时访问一个格式。则它必须保持外部同步。</span></span><br><span class="line">    <span class="comment">//  原因：SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。</span></span><br><span class="line">    <span class="comment">//  clear是线程不安全的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parse</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方案1:将SimpleDateFormat定义成局部变量。</span></span><br><span class="line">    <span class="comment">// 缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。</span></span><br><span class="line">    <span class="comment">// 线程少的时候可以考虑，如果线程多的话就不合适了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方案2   ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; sdfThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Date <span class="title function_">parseByThreadLocal</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> sdfThreadLocal.get().parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方案3 DateTimeFormatter 代替 SimpleDateFormat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，</span></span><br><span class="line"><span class="comment">    DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable</span></span><br><span class="line"><span class="comment">    thread-safe。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">DATE_TIME_FORMAT</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DATE_TIME_FORMAT.format(localDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">parseByDateTimeFormatter</span><span class="params">(String dateString)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateString, DATE_TIME_FORMAT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(ThreadLocalDateUtils.parse(&quot;2011-11-11 11:11:11&quot;));</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line"><span class="comment">                    System.out.println(sdf.parse(&quot;2011-11-11 11:11:11&quot;));</span></span><br><span class="line"><span class="comment">                    sdf = null;*/</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(ThreadLocalDateUtils.parse(<span class="string">&quot;2011-11-11 11:11:11&quot;</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//remove();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302347505.png" alt="image-20240530234737568"></p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302352618.png" alt="Snipaste_2024-05-30_23-49-06"></p>
<h3 id="Thread、ThreadLocal、ThreadLocalMap-关系"><a href="#Thread、ThreadLocal、ThreadLocalMap-关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap 关系"></a>Thread、ThreadLocal、ThreadLocalMap 关系</h3><p>ThreadLocal源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment"> * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>说明：Thread里面有一个ThreadLocal</p>
<p>ThreadLocal和ThreadLocalMap：</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310006877.png" alt="image-20240531000603742"></p>
<p>说明：ThreadLocal里面有一个ThreadLocalMap</p>
<p>ThreadLocalMap实际上是一个以ThreadLocal实例为key，任意对象为Value的Entry数组。当给你我们为Thread Local变量赋值的时候，实际上就是以当前的ThreadLocal为key,值为value的Entry往这个ThreadLocalMap中存放。</p>
<p>ThreadLocalMap源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：ThreadLocalMap中实际中的存储是用Entry，是弱引用</p>
<h2 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h2><h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<h3 id="谁惹的祸？"><a href="#谁惹的祸？" class="headerlink" title="谁惹的祸？"></a>谁惹的祸？</h3><h4 id="强引用、软引用、弱引用、虚引用分别是什么？"><a href="#强引用、软引用、弱引用、虚引用分别是什么？" class="headerlink" title="强引用、软引用、弱引用、虚引用分别是什么？"></a>强引用、软引用、弱引用、虚引用分别是什么？</h4><p>ThreadLocalMap与WeakReference ，ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)，不过是经过了两层包装的ThreadLocal对象：<br>（1）第一层包装是使用 WeakReference&lt;&lt;ThreadLocal&lt;<?>> 将ThreadLocal对象变成一个弱引用的对象；
（2）第二层包装是定义了一个专门的类 Entry 来扩展 WeakReference<<ThreadLocal<<?>&gt;：</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310018509.png" alt="image-20240531001810543"></p>
<h5 id="强引用-默认支持模式"><a href="#强引用-默认支持模式" class="headerlink" title="强引用(默认支持模式)"></a>强引用(默认支持模式)</h5><p>​	&#x3D;&#x3D;当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收&#x3D;&#x3D;，死都不收。</p>
<p>​	强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p>
<p>​	对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();<span class="comment">//默认，强引用,死了都不放手</span></span><br><span class="line">    System.out.println(<span class="string">&quot;gc before: &quot;</span> + myObject);</span><br><span class="line">    myObject = <span class="literal">null</span>;</span><br><span class="line">    System.gc();<span class="comment">//手动挡的方式开启Gc回收。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;gc after: &quot;</span> + myObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p>
<p>对于只有软引用的对象来说，</p>
<pre><code> 当系统内存充足时它         不会     被回收，

 当系统内存不足时它         会       被回收。
</code></pre>
<p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">softReference</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());<span class="comment">//软引用</span></span><br><span class="line"><span class="comment">// 1、内存够用，不会回收</span></span><br><span class="line">    <span class="comment">/*内存够用</span></span><br><span class="line"><span class="comment">    System.out.println(&quot;gc before内存够用: &quot;+softReference);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    System.gc();//手动挡的方式开启Gc回收。</span></span><br><span class="line"><span class="comment">    try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    System.out.println(&quot;gc after内存够用: &quot;+softReference);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、内存不够用，回收</span></span><br><span class="line">    <span class="comment">//设置参数-Xms10m -Xmx10m</span></span><br><span class="line">    System.out.println(<span class="string">&quot;gc before: &quot;</span> + softReference);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span> + softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">weakReference</span><span class="params">()</span> &#123;</span><br><span class="line">    WeakReference&lt;MyObject&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;gc before: &quot;</span> + weakReference.get());</span><br><span class="line"></span><br><span class="line">    System.gc();<span class="comment">//手动挡的方式开启Gc回收。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;gc after: &quot;</span> + weakReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如有一个应用需要读取大量的本地图片:</p>
<ul>
<li>如果每次读取图片都从硬盘读取则会严重影响性能,</li>
<li>如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。</li>
</ul>
<p>设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p>
<p>Map&lt;String, SoftReference<Bitmap>&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference<Bitmap>&gt;();</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p> 虚引用需要java.lang.ref.PhantomReference类来实现。</p>
<p>顾名思义，就是&#x3D;&#x3D;形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。&#x3D;&#x3D;<br>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，<br>它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。</p>
<p>虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。</p>
<p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作 。</p>
<p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</p>
<h5 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h5><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310047366.png" alt="image-20240531004657979"></p>
<h5 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h5><p>每个Thread对象维护着一个ThreadLocalMap的引用<br>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储<br>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象<br>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象<br>ThreadLocal本身并不存储值，它只是自己作为一个key来让线程从ThreadLocalMap获取value，正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～</p>
<h3 id="为什么要用弱引用-不用如何？"><a href="#为什么要用弱引用-不用如何？" class="headerlink" title="为什么要用弱引用?不用如何？"></a>为什么要用弱引用?不用如何？</h3><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310053775.png" alt="image-20240531005313750"></p>
<h4 id="为什么源代码用弱引用？"><a href="#为什么源代码用弱引用？" class="headerlink" title="为什么源代码用弱引用？"></a>为什么源代码用弱引用？</h4><p>为什么源代码用弱引用?<br>当function01方法执行完毕后，栈帧销毁强引用 tl 也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象<br>若这个<strong>key</strong>引用是<strong>强引用</strong>，就会导致<strong>key</strong>指向的<strong>ThreadLocal</strong>对象及v指向的对象不能被<strong>gc</strong>回收，造成内存泄漏；<br>若这个<strong>key</strong>引用是<strong>弱引用</strong>就<strong>大概率</strong>会减少内存泄漏的问题(<strong>还有一个key为null的雷</strong>)。使用弱引用，就可以使<strong>ThreadLocal</strong>对象在方法执行完毕后顺利被回收且<strong>Entry</strong>的<strong>key引用指向为null。</strong></p>
<p>–下面这句话，我们后续聊，本节先忽略<br>此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。</p>
<p>1 当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl&#x3D;null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。…</p>
<h5 id="key为null的entry，原理解析"><a href="#key为null的entry，原理解析" class="headerlink" title="key为null的entry，原理解析"></a>key为null的entry，原理解析</h5><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链。</p>
<p>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug。</p>
<p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310058199.png" alt="image-20240531005758402"></p>
<p>set、get方法会去检查所有键为null的Entry对象</p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>​	从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>ThreadLocal 并不解决线程间共享数据的问题</li>
<li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li>
<li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li>
<li>每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li>
<li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</li>
<li>都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法</li>
</ol>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Future和Callable接口"><a href="#Future和Callable接口" class="headerlink" title="Future和Callable接口"></a>Future和Callable接口</h3><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p>
<p>Callable接口中定义了需要有返回的任务需要实现的方法。比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzyy.study.test;<span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;    </span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            </span><br><span class="line">      System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            </span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">      &#125;            </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>+ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        </span><br><span class="line">      &#125;</span><br><span class="line">                                                    );       </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>);        </span><br><span class="line">    t1.start();        </span><br><span class="line">    <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)              	//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());        </span></span><br><span class="line">    <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候        System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get(1L,TimeUnit.SECONDS));        System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot; run... here&quot;);    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>Future实际采用FutureTask实现，该对象相当于是消费者和生产者的桥梁，消费者通过 FutureTask 存储任务的处理结果，更新任务的状态：未开始、正在处理、已完成等。</p>
<p>1、get()阻塞：一旦调用get()方法，不管是否计算完成都会导致阻塞，o(╥﹏╥)o</p>
<p>2、get(long timeout, TimeUnit unit)：只等待一段时间，过时不侯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="comment">//构建futureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="comment">//作为Runnable入参</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;task运行结果：&quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正在计算&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、isDone()轮询：轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果；如果想要异步获取结果,通常都会以轮询的方式去获取结果尽量不要阻塞；执行结束（完成&#x2F;取消&#x2F;异常）返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果线程结束了，则获取结果</span></span><br><span class="line">            <span class="keyword">if</span> (futureTask.isDone()) &#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qijianyeah.github.io">QiJian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qijianyeah.github.io/2024/11/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://qijianyeah.github.io/2024/11/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://qijianyeah.github.io" target="_blank">QiJian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">java 知识总结</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/" title="深入理解MySQL底层数据结构算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解MySQL底层数据结构算法</div></div><div class="info-2"><div class="info-item-1">什么是索引？ 索引是帮助MySQL高效获取数据的排好序的数据结构 索引的数据结构：二叉树，红黑树，Hash表，B-树  分析select语句1select * from t_user where age = 18;  没有加索引没有加索引时，MySQL底层是通过一行一行的进行查找的，当找找到age&#x3D;18的字段后依然不能确定后面的数据时候还有age&#x3D;18的字段，所以依然需要继续查找，一次查找就是一次磁盘IO（Mysql 通过磁盘 IO...</div></div></div></a><a class="pagination-related  no-desc" href="/2024/11/14/comment/" title="留言版"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">留言版</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" title="并发编程（一）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-17</div><div class="info-item-2">并发编程（一）</div></div><div class="info-2"><div class="info-item-1">Java 并发编程（一）1、相关概念进程和线程进程：进程指正在运行的程序，进程拥有一个完整的、私有的基本运行资源集合。通常，每个进程都有自己的内存空间。 线程：有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。  Java...</div></div></div></a><a class="pagination-related" href="/2024/12/23/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/" title="悲观锁和乐观锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-23</div><div class="info-item-2">悲观锁和乐观锁</div></div><div class="info-2"><div class="info-item-1">悲观锁和乐观锁1、初步认识悲观锁：&#x3D;&#x3D;认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。&#x3D;&#x3D;synchronized关键字和Lock的实现类都是悲观锁。适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源。 12345678//=============悲观锁的调用方式public synchronized void m1()&#123;//加锁后的业务逻辑......&#125;// 保证多个线程使用的是同一个lock对象的前提下ReentrantLock lock = new ReentrantLock(); // 默认falsepublic void m2()...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">QiJian</div><div class="author-info-description">拾一片落叶，夹在岁月的书页里，留作回忆的风景。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_43663493" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?qqqqqqqqqq=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1111111111@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的个人博客！这里主要分享编程、技术与开源项目的相关内容，适合开发者和技术爱好者。感谢关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Java数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%EF%BC%9Abyte-short-int-long"><span class="toc-number">1.1.1.</span> <span class="toc-text">整数型：byte short int long</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">布尔型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">1.2.</span> <span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E3%80%81-StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">String 、 StringBuffer、StringBuilder 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String-%E2%80%9Cabc%E2%80%9D"><span class="toc-number">1.3.1.</span> <span class="toc-text">new String(“abc”) ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F%E5%8C%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">String 的几种拼接方式区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">使用 + 拼接字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8concat"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">使用concat:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.</span> <span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">1.5.</span> <span class="toc-text">重载与重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">Object 类通用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-equals"><span class="toc-number">1.6.</span> <span class="toc-text">&#x3D;&#x3D; 与 equals</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.1.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.2.</span> <span class="toc-text">方法的参数传递机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">static</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">类初始化过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">实例初始化过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">获取用键盘输入常用的两种方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">Java 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">2.0.1.</span> <span class="toc-text">容器分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.</span> <span class="toc-text">Java并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">面试问题：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">Java集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">IO编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E2%80%9C%E9%94%81%E2%80%9D"><span class="toc-number">5.</span> <span class="toc-text">Java“锁”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E5%8F%88%E5%90%8D%E9%80%92%E5%BD%92%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">可重入锁(又名递归锁)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%A7%8D%E7%B1%BB"><span class="toc-number">5.3.1.</span> <span class="toc-text">可重入锁种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">隐式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%BF%AB"><span class="toc-number">5.3.1.1.1.</span> <span class="toc-text">同步快</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.1.1.2.</span> <span class="toc-text">同步方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E7%9A%84%E9%87%8D%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">Synchronized的重入的实现机理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81%EF%BC%88%E5%8D%B3Lock%EF%BC%89"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">显式锁（即Lock）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%8F%8A%E6%8E%92%E6%9F%A5"><span class="toc-number">5.4.</span> <span class="toc-text">死锁及排查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">JUC并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">6.1.</span> <span class="toc-text">线程基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.2.1.</span> <span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2"><span class="toc-number">6.2.2.</span> <span class="toc-text">线程启动和停止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9A%82%E5%81%9C%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="toc-number">6.2.3.</span> <span class="toc-text">线程暂停和中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">6.2.4.</span> <span class="toc-text">线程的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">6.3.1.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">多线程的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">6.3.3.</span> <span class="toc-text">多线程的代价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">6.4.</span> <span class="toc-text">并发编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">6.4.1.</span> <span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">6.4.2.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%89%E5%85%A8"><span class="toc-number">6.4.3.</span> <span class="toc-text">对象的安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">局部基本类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">局部的对象引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.4.</span> <span class="toc-text">对象成员(成员变量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">6.4.5.</span> <span class="toc-text">不可变性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">6.6.</span> <span class="toc-text">CAS乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%9D%97"><span class="toc-number">6.7.</span> <span class="toc-text">Synchronized块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.7.1.</span> <span class="toc-text">同步块的分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E9%94%81%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.7.2.</span> <span class="toc-text">Synchronized锁的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.7.2.1.1.</span> <span class="toc-text">对象头详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mark-Word%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.7.2.1.2.</span> <span class="toc-text">Mark Word的结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%94%81"><span class="toc-number">6.7.2.2.</span> <span class="toc-text">无锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">6.7.2.3.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">6.7.2.3.1.</span> <span class="toc-text">偏向锁的获取流程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81JVM%E5%91%BD%E4%BB%A4"><span class="toc-number">6.7.2.3.2.</span> <span class="toc-text">偏向锁JVM命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">6.7.2.3.3.</span> <span class="toc-text">偏向锁的撤销</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">6.7.2.4.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88Spin-Lock%EF%BC%89"><span class="toc-number">6.7.2.4.1.</span> <span class="toc-text">自旋锁（Spin Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E9%94%81%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%B8%8D%E5%90%8C"><span class="toc-number">6.7.2.4.2.</span> <span class="toc-text">轻量锁与偏向锁的区别和不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">6.7.2.5.</span> <span class="toc-text">重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E9%94%81%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.7.2.6.</span> <span class="toc-text">总结：锁对象状态转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97Volatile"><span class="toc-number">6.8.</span> <span class="toc-text">关键字Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%ABvolatile%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%98%E9%87%8F%E6%9C%892%E5%A4%A7%E7%89%B9%E7%82%B9"><span class="toc-number">6.8.1.</span> <span class="toc-text">被volatile修改的变量有2大特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-number">6.8.2.</span> <span class="toc-text">volatile的内存语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E5%BF%85%E9%A1%BB%E6%8B%BF%E4%B8%8B"><span class="toc-number">6.8.3.</span> <span class="toc-text">内存屏障(面试重点必须拿下)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">6.8.3.1.</span> <span class="toc-text">保证可见性和有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.8.3.2.</span> <span class="toc-text">volatile 不能保证原子性的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-number">6.8.3.3.</span> <span class="toc-text">什么是内存屏障？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM-%E5%B0%B1%E5%B0%86%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E2%BC%8A%E7%AD%96%E7%95%A5%E5%88%86%E4%B8%BA-4-%E7%A7%8D"><span class="toc-number">6.8.3.4.</span> <span class="toc-text">JMM 就将内存屏障插⼊策略分为 4 种</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E7%89%B9%E6%80%A7"><span class="toc-number">6.8.4.</span> <span class="toc-text">volatile特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">6.8.4.1.</span> <span class="toc-text">保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B"><span class="toc-number">6.8.4.2.</span> <span class="toc-text">volatile变量的读写过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">6.8.4.3.</span> <span class="toc-text">没有原子性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%A6%81%E9%87%8D%E6%8E%92"><span class="toc-number">6.8.5.</span> <span class="toc-text">指令禁重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.5.1.</span> <span class="toc-text">重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">6.8.6.</span> <span class="toc-text">volatile的底层实现是通过内存屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E6%9C%89%E5%85%B3%E7%9A%84%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">6.8.6.1.</span> <span class="toc-text">volatile有关的禁止指令重排的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%B1%8F%E9%9A%9C%E7%9A%84%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B5"><span class="toc-number">6.8.6.2.</span> <span class="toc-text">四大屏障的插入情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8volatile"><span class="toc-number">6.8.7.</span> <span class="toc-text">如何正确使用volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DCL%E5%8F%8C%E7%AB%AF%E9%94%81%E7%9A%84%E5%8F%91%E5%B8%83"><span class="toc-number">6.8.8.</span> <span class="toc-text">DCL双端锁的发布</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">7.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">ThreadLocal是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.2.</span> <span class="toc-text">api介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-number">7.2.2.</span> <span class="toc-text">get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">7.2.3.</span> <span class="toc-text">set()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-number">7.2.4.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="toc-number">7.2.5.</span> <span class="toc-text">案例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.3.</span> <span class="toc-text">ThreadLocal源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E3%80%81ThreadLocal%E3%80%81ThreadLocalMap-%E5%85%B3%E7%B3%BB"><span class="toc-number">7.3.1.</span> <span class="toc-text">Thread、ThreadLocal、ThreadLocalMap 关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.</span> <span class="toc-text">ThreadLocal内存泄露问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">7.4.1.</span> <span class="toc-text">什么是内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%81%E6%83%B9%E7%9A%84%E7%A5%B8%EF%BC%9F"><span class="toc-number">7.4.2.</span> <span class="toc-text">谁惹的祸？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">强引用、软引用、弱引用、虚引用分别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8-%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.2.1.1.</span> <span class="toc-text">强引用(默认支持模式)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">7.4.2.1.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">7.4.2.1.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">7.4.2.1.4.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GCRoots%E5%92%8C%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.2.1.5.</span> <span class="toc-text">GCRoots和四大引用小总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">7.4.2.1.6.</span> <span class="toc-text">关系：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8-%E4%B8%8D%E7%94%A8%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">7.4.3.</span> <span class="toc-text">为什么要用弱引用?不用如何？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%BA%90%E4%BB%A3%E7%A0%81%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">为什么源代码用弱引用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#key%E4%B8%BAnull%E7%9A%84entry%EF%BC%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">7.4.3.1.1.</span> <span class="toc-text">key为null的entry，原理解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">结论：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">7.6.</span> <span class="toc-text">CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future%E5%92%8CCallable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.6.1.</span> <span class="toc-text">Future和Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask"><span class="toc-number">7.6.2.</span> <span class="toc-text">FutureTask</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/23/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/" title="悲观锁和乐观锁">悲观锁和乐观锁</a><time datetime="2024-12-23T15:12:11.000Z" title="发表于 2024-12-23 23:12:11">2024-12-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/20/LinkedHashMap%E7%B1%BB/" title="LinkedHashMap类">LinkedHashMap类</a><time datetime="2024-11-20T15:11:42.000Z" title="发表于 2024-11-20 23:11:42">2024-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/17/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Explain详解与索引最佳实践">Explain详解与索引最佳实践</a><time datetime="2024-11-16T19:04:32.000Z" title="发表于 2024-11-17 03:04:32">2024-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="深入理解MySQL底层数据结构与算法">深入理解MySQL底层数据结构与算法</a><time datetime="2024-11-16T18:54:29.000Z" title="发表于 2024-11-17 02:54:29">2024-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/17/RocketMQ%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="RocketMQ的编程模型">RocketMQ的编程模型</a><time datetime="2024-11-16T18:29:21.000Z" title="发表于 2024-11-17 02:29:21">2024-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By QiJian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">QiJian 柒间</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>