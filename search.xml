<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Explain详解与索引最佳实践</title>
      <link href="/2024/11/17/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/11/17/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="Explain工具介绍"><a href="#Explain工具介绍" class="headerlink" title="Explain工具介绍"></a>Explain工具介绍</h3><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈</p><p>explain ：执行查询会返回执行计划的信息，而不是执行这条SQL</p><p>注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中</p><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">USE t_explain;</span><br><span class="line">DROP TABLE IF EXISTS `actor`; </span><br><span class="line">CREATE TABLE `actor` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `name` varchar(<span class="number">45</span>) DEFAULT NULL,</span><br><span class="line">  `update_time` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;2017-12-22 15:27:18&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;2017-12-22 15:27:18&#x27;</span>), (<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;2017-12-22 15:27:18&#x27;</span>);</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `film`;</span><br><span class="line">CREATE TABLE `film` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(<span class="number">10</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span>,</span><br><span class="line">  KEY `idx_name` (`name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `film` (`id`, `name`) VALUES (<span class="number">3</span>,<span class="string">&#x27;film0&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;film1&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;film2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `film_actor`;</span><br><span class="line">CREATE TABLE `film_actor` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `film_id` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `actor_id` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `remark` varchar(<span class="number">255</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span>,</span><br><span class="line">  KEY `idx_film_actor_id` (`film_id`,`actor_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="explain实战"><a href="#explain实战" class="headerlink" title="explain实战"></a>explain实战</h2><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行；</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170304599.png" alt="img"></p><p>注意：explain再不同的版本有微小的差别。</p><p><strong>explain 两个变种</strong></p><p>1）<strong>explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。</p><p>2）<strong>explain partitions</strong>：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p><p>rows * <em>filtered&#x2F;100</em> 可以<strong>估算</strong>出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）</p><p><strong>explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain extended select * from actor;</span><br><span class="line">show warnings;</span><br></pre></td></tr></table></figure><p>执行上面两条语句后截图如下：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305180.png" alt="img"></p><h3 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h3><h4 id="id"><a href="#id" class="headerlink" title="id:"></a><strong>id:</strong></h4><p>​select 的序列号，有几个 select 就有几个id</p><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type:"></a><strong>select_type:</strong></h4><p>​表示对应行是简单还是复杂的查询</p><p>1）simple：简单查询。查询不包含子查询和union</p><p>2）primary：复杂查询中最外层的 select<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）<br>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p><p>5）union：在 union 中的第二个和随后的 select</p><h4 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h4><p>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是  格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p><h4 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h4><p>表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。</p><p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 。一般来说，得保证查询达到range级别，最好达到ref<br><strong>NULL：</strong>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。</p><p><strong>const, system：</strong>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system</p><p><strong>eq_ref：</strong>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p><p><strong>ref：</strong>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><ol><li>简单 select 查询，name是普通索引（非唯一索引）</li><li>关联表查询，<strong>索引关联查询的字段。</strong></li></ol><p><strong>range：</strong>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</p><p>不要使用select * from table; 全表查找，如果数据太大的话内存可能会被占满。当没有添加条件的时候，不管是使用主键索引还是辅助索引都是从根节点开始查找的。</p><p><strong>index：</strong>扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。</p><p><strong>注意： 如果搜索的结果集在主键索引和辅助索引都存在的话，那么会优先选择辅助索引。</strong>如果辅助索引不全有，那么需要回表效率就会比较低。</p><p><strong>ALL：</strong>即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p><h4 id="possible-keys："><a href="#possible-keys：" class="headerlink" title="possible_keys："></a><strong>possible_keys</strong>：</h4><p>​这一列显示查询可能使用哪些索引来查找。</p><h4 id="key："><a href="#key：" class="headerlink" title="key："></a><strong>key：</strong></h4><p>​这一列显示mysql实际采用哪个索引来优化对该表的访问。</p><h4 id="key-len："><a href="#key-len：" class="headerlink" title="key_len："></a><strong>key_len：</strong></h4><p>​这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。如果索引字段使用的是int 那么 key_len 显示 4。如果使用的是联合 那么就是所有联合索引中的索引字段长度之和。</p><h4 id="ref列"><a href="#ref列" class="headerlink" title="ref列:"></a><strong>ref列:</strong></h4><p>​这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows:"></a><strong>rows:</strong></h4><p>​mysql估计要读取并检测的行数,并不是结果集里的行数。</p><h4 id="Extra列："><a href="#Extra列：" class="headerlink" title="Extra列："></a><strong>Extra列：</strong></h4><p>展示的是额外信息</p><ul><li>Using index：使用覆盖索引</li><li>Using where：使用 where 语句来处理结果，并且查询的列未被索引覆盖。</li><li>Using index condition：查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</li><li>Using temporary：mysql需要创建一张临时表来处理查询。<strong>需要进行优化，首先是想到用索引来优化。</strong><br><code>explain select distinct name from actor;</code>没有索引需要将结果查询出来，然后在零时的内存里的表进行去重。<br><code>explain select distinct name from film;</code>建立了name的索引，此时查询，extra是using index,没有用临时表。</li><li>Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。<br><code>explain select * from actor order by name;</code>未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。<br><code>explain select * from film order by name;</code>建立了idx_name索引,此时查询时extra是using index。</li><li>Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段。</li></ul><p>覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。这时不需要回表。</p><p>select 1 from table – 增加临时列，放在表最后， 每行值为1</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">24</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `position` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">  `hire_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_name_age_position` (`name`,`age`,`position`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;员工记录表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(name,age,position,hire_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;LiLei&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;manager&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(name,age,position,hire_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;HanMeimei&#x27;</span>, <span class="number">23</span>,<span class="string">&#x27;dev&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(name,age,position,hire_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;Lucy&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;dev&#x27;</span>,NOW());</span><br></pre></td></tr></table></figure><p>上面的employees表中使用了联合索引包含三个字段<code>name</code>,<code>age</code>,<code>position</code>。</p><p>最左前缀匹配原则：在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>索引是否生效就看 sql语句用到的结果集，是否在索引树里能够定位。并且保证有序。</p><h4 id="全职匹配"><a href="#全职匹配" class="headerlink" title="全职匹配"></a>全职匹配</h4><p>查看执行情况<code>explain select * from employees where name = &#39;lilei&#39;;</code> (<strong>只使用name索引</strong>)</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305448.png" alt="img"></p><p>key_len :  3n + 2 &#x3D; 3 * 24 + 2  (这一条sql语句只使用了name的索引)</p><p><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22;</code>（<strong>使用name 和 age索引</strong>）</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305467.png" alt="img"></p><p>key_len : name_len + age_len &#x3D; (3*24 + 2) + 4 &#x3D; 78</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure><p>（<strong>使用name , age 和 position索引</strong>）</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305450.png" alt="img"></p><p>key_len: name_len + age_len+ position_len  &#x3D; (3<em>24 + 2) + 4 + 20</em>  3 + 2 &#x3D; 140</p><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a><strong>最左前缀法则</strong></h4><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。但是如果自己写的查询语句没有满足该原则，MySQL内部回进行优化，试其满足。但是<strong>建议自己写时就要满足，不要加重MySQL的负担。</strong></p><h4 id="索引列上做任何操作"><a href="#索引列上做任何操作" class="headerlink" title="索引列上做任何操作"></a><strong>索引列上做任何操作</strong></h4><p><strong>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），避免索引失效而转向全表扫描</strong></p><p>原因：因为索引树里面没有这些字段</p><h4 id="存储引擎不能使用索引中范围条件右边的列"><a href="#存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="存储引擎不能使用索引中范围条件右边的列"></a>存储引擎不能使用索引中范围条件右边的列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name<span class="operator">=</span> <span class="string">&#x27;LiLei&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">AND</span> position <span class="operator">=</span><span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name<span class="operator">=</span> <span class="string">&#x27;LiLei&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">22</span> <span class="keyword">AND</span> position <span class="operator">=</span><span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305142.png" alt="img"></p><p>在第一个字段相等的情况下，第二个字段一定是有序的(范围查找)。按照最左前最法则，前面的字段索引都用到了，那么接下来的一个小组有序</p><h4 id="减少-select-语句"><a href="#减少-select-语句" class="headerlink" title="减少 select * 语句"></a>减少 select * 语句</h4><p>尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</p><h4 id="无法使用索引会导致全表扫描"><a href="#无法使用索引会导致全表扫描" class="headerlink" title="无法使用索引会导致全表扫描"></a>无法使用索引会导致全表扫描</h4><p>mysql在使用不等于（！&#x3D;或者&lt;&gt;），not in ，not exists 的时候无法使用索引会导致全表扫描&lt; 小于、 &gt; 大于、 &lt;&#x3D;、&gt;&#x3D; 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引</p><h4 id="is-null-is-not-null-一般情况下也无法使用索引"><a href="#is-null-is-not-null-一般情况下也无法使用索引" class="headerlink" title="is null,is not null 一般情况下也无法使用索引"></a>is null,is not null 一般情况下也无法使用索引</h4><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p><p>%字符串:不能走索引,百分号在前会让MySQL认为字符串之前还有其他字符串，跳过这其他字符串在索引树里就不是有序的了。</p><p>字符串%：能走索引，使用索引的字符串，索引就可以走索引。</p><p>问题：解决like’%字符串%’索引不被使用的方法？<br>a）使用覆盖索引，查询字段必须是建立覆盖索引字段</p><p>b）如果不能使用覆盖索引则可能需要借助搜索引擎</p><h4 id="字符串不加单引号索引失效"><a href="#字符串不加单引号索引失效" class="headerlink" title="字符串不加单引号索引失效"></a>字符串不加单引号索引失效</h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305007.png" alt="img"></p><h4 id="少用or或in"><a href="#少用or或in" class="headerlink" title="少用or或in"></a>少用or或in</h4><p>用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评<br>估是否使用索引，详见范围查询优化</p><h4 id="范围查询优化"><a href="#范围查询优化" class="headerlink" title="范围查询优化"></a>范围查询优化</h4><p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如：可能是由于单次数据量查询过大导致优化器最终选择不走索引。<br>优化方法：可以将大的范围拆分成多个小范围。</p><h3 id="索引使用总结："><a href="#索引使用总结：" class="headerlink" title="索引使用总结："></a>索引使用总结：</h3><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170305025.png" alt="img"></p><p><strong>like KK%相当于&#x3D;常量，%KK和%KK% 相当于范围</strong></p><p>说明：</p><p>key_len计算规则如下：</p><ul><li><p>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数，</strong>如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节</p></li><li></li><li><p>char(n)：如果存汉字长度就是 3n 字节</p></li><li><p>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</p></li><li><p>数值类型</p></li><li></li><li><p>tinyint：1字节</p></li><li><p>smallint：2字节</p></li><li><p>int：4字节</p></li><li><p>bigint：8字节</p></li><li><p>时间类型</p></li><li></li><li><p>date：3字节</p></li><li><p>timestamp：4字节</p></li><li><p>datetime：8字节</p></li><li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><p>char：定长，效率高，一般用于固定长度的表单提交数据存储 ；例如：身份证号，手机号，电话，密码等</p><p>varchar：不定长，效率偏低</p>]]></content>
      
      
      <categories>
          
          <category> mysql 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解MySQL底层数据结构与算法</title>
      <link href="/2024/11/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ol><li>索引是帮助MySQL高效获取数据的排好序的数据结构</li><li>索引的数据结构：二叉树，红黑树，Hash表，B-树</li></ol><p>没有加索引</p><p>没有加索引时，MySQL底层是一行一行的进行查找的，当找到age&#x3D;18的字段后依然不能确定后面的数据是否还有age&#x3D;18的字段，所以依然需要继续查找，一次查找就是一次磁盘IO（Mysql 通过磁盘 IO 次数衡量查询效率的），如果一张表有10万条数据那么就需要进行10万次的查找，把数据从磁盘加载到内存的速度不快，如果数据量大的话，需要花费相当多的时间，才能扫描完整张表。</p><p>B-Tree</p><p>叶节点具有相同的深度，叶子节点的指针为空</p><p>所有索引元素不重复</p><p>节点中的数据索引从左到右递增排列</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170256516.png" alt="img"></p><p>B+Tree(B-Tree变种)</p><p>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</p><p>叶子节点包含所有索引字段</p><p>叶子节点用指针连接，提高区间访问的性能</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170256253.png" alt="img"></p><p>查找算法：折半查找 ， 找30–(将上图最上面的数据页加载到内存) –&gt; (15,56)—（将上图第二行的数据页加载到内存）–&gt;(20,49)–&gt;…  30</p><p>一个 B+ 树的节点中到底存多少个元素最合适你有了解过么？</p><p>放满可以存放多少 ： 16kb&#x2F;(8+6)b  X  16kb&#x2F;(8+6)b  X  16KB</p><p>B+ 树中一个节点为一页或页的倍数最为合适。(页是InnoDB管理存储空间的基本单位，InnoDB将数据库中的数据存储在页这个基本存储单位里。页也是内存和磁盘交互的基本单位，数据库从磁盘中读取若干个页面大小的数据到内存，也将内存中若干个大小的数据刷新到磁盘。一个页的内存大小为16KB)</p><p>如果一个节点的大小小于 1 页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。如果一个节点的大小大于 1 页，比如 1.2 页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170256341.png" alt="img"></p><p>MyISAM索引文件和数据文件是分离的(非聚集)</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170256321.png" alt="img"></p><h4 id="索引存储在文件系统中"><a href="#索引存储在文件系统中" class="headerlink" title="索引存储在文件系统中"></a><strong>索引存储在文件系统中</strong></h4><p>索引是占据物理空间的，在不同的存储引擎中，索引存在的文件也不同</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170256302.png" alt="img"></p><p>InnoDB索引实现(聚集)</p><p>表数据文件本身就是按B+Tree组织的一个索引结构文件</p><p>聚集索引-叶节点包含了完整的数据记录</p><p>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？</p><p>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170257973.png" alt="img"></p><p>联合索引的底层存储结构长什么样？</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411170257683.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ的编程模型</title>
      <link href="/2024/11/17/RocketMQ%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/11/17/RocketMQ%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="RocketMQ的编程模型"><a href="#RocketMQ的编程模型" class="headerlink" title="RocketMQ的编程模型"></a>RocketMQ的编程模型</h2><ul><li>消息发送者的固定步骤1.创建消息生产者producer，并制定生产者组名<br>2.指定Nameserver地址<br>3.启动producer<br>4.创建消息对象，指定主题Topic、Tag和消息体<br>5.发送消息<br>6.关闭生产者producer</li><li>消息消费者的固定步骤1.创建消费者Consumer，制定消费者组名<br>2.指定Nameserver地址<br>3.订阅主题Topic和Tag<br>4.设置回调函数，处理消息<br>5.启动消费者consumer</li></ul><h2 id="RocketMQ的消息样例"><a href="#RocketMQ的消息样例" class="headerlink" title="RocketMQ的消息样例"></a>RocketMQ的消息样例</h2><h3 id="1-消息的发送分为三种："><a href="#1-消息的发送分为三种：" class="headerlink" title="1.消息的发送分为三种："></a>1.消息的发送分为三种：</h3><p>同步发送，异步发送，单向发送。</p><p>单向发送：表示生产者把消息向mq推送后就不管了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg);//没有返回值</span><br></pre></td></tr></table></figure><p>同步发送：当生产者发送消息给mq并且mq相应后，再继续自己的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br></pre></td></tr></table></figure><p>异步发送：当生产者发送消息给mq发送消息后就不管了，接着做自己的事情，但是会给mq一个回调函数。mq在完成消息后会回过来请求生产者，生产者会有一个回调的函数，在回调的方法里面执行逻辑，但是里面执行的逻辑pruducer就不管了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String[] args) <span class="keyword">throws</span> MQClientException, InterruptedException, UnsupportedEncodingException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;Jodie_Daily_test&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.85.3:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">messageCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//由于是异步发送，这里引入一个countDownLatch，保证所有Producer发送消息的回调方法都执行完了再停止Producer服务。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(messageCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        producer.shutdown();</span><br></pre></td></tr></table></figure><h3 id="使用消费者消费消息。"><a href="#使用消费者消费消息。" class="headerlink" title="使用消费者消费消息。"></a>使用消费者消费消息。</h3><p>消费者消费消息有两种模式，一种是消费者主动去Broker上拉取消息的拉模式，另一种是消费者等待Broker把消息推送过来的推模式。</p><h3 id="2-顺序消息"><a href="#2-顺序消息" class="headerlink" title="2.顺序消息"></a>2.顺序消息</h3><p>​不管订单在多个Consumer实例之前是如何分配的，每个订单下的多条消息顺序都是固定从0~n的。RocketMQ保证的是消息的<strong>局部有序，而不是全局有序</strong>。</p><p><img src="/RocketMQ%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.assets/image-20220601143000520.png" alt="image-20220601143000520"></p><p>​为了保障消息的有序c端获取消息先从一个messagequeue中获取所有消息，再从下一个获取。保证了消息有序。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                context.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">for</span>(MessageExt msg:msgs)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到消息内容 &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-广播消息"><a href="#3-广播消息" class="headerlink" title="3 广播消息"></a>3 广播消息</h3><p>​广播消息并没有特定的消息消费者样例，这是因为这涉及到消费者的集群消费模式。在集群状态MessageModel.CLUSTERING)下，每一条消息只会被同一个消费者组中的一个实例消费到(这跟kafka和rabbitMQ的集群模式是一样的)。而广播模式则是把消息发给了所有订阅了对应主题的消费者，而不管消费者是不是同一个消费者组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure><h3 id="4-延迟消息"><a href="#4-延迟消息" class="headerlink" title="4 延迟消息"></a>4 延迟消息</h3><p>​延迟消息实现的效果就是在调用producer.send方法后，消息并不会立即发送出去，而是会等一段时间再发送出去。这是RocketMQ特有的一个功能。</p><p>​延迟时间的设置就是在Message消息对象上设置一个延迟级别message.setDelayTimeLevel(3);&#x2F;&#x2F;10秒，3代表级别。（但是在商业版中是可以直接设置时间的）</p><p><img src="/RocketMQ%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.assets/image-20220601145358527.png" alt="image-20220601145358527"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Instantiate a producer to send scheduled messages</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// Launch producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// This message will be delivered to consumer 10 seconds later.</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// Send the message</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// Shutdown producer after use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-批量消息"><a href="#5-批量消息" class="headerlink" title="5 批量消息"></a>5 批量消息</h3><p>​批量消息是指将多条消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;Tag&quot;</span>, <span class="string">&quot;OrderID001&quot;</span>, <span class="string">&quot;Hello world 0&quot;</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;Tag&quot;</span>, <span class="string">&quot;OrderID002&quot;</span>, <span class="string">&quot;Hello world 1&quot;</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;Tag&quot;</span>, <span class="string">&quot;OrderID003&quot;</span>, <span class="string">&quot;Hello world 2&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">producer.send(messages);</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure><p>​官网以及测试代码中有关键的注释：如果批量消息大于1MB就不要用一个批次发送，而要拆分成多个批次消息发送。也就是说，一个批次消息的大小不要超过1MB。</p><p>​实际使用时，这个1MB的限制可以稍微扩大点，实际最大的限制是4194304字节，大概4MB。但是使用批量消息时，这个消息长度确实是必须考虑的一个问题。而且批量消息的使用是有一定限制的，这些消息应该有相同的Topic，相同的waitStoreMsgOK。而且不能是延迟消息、事务消息等。</p><h3 id="6-过滤消息"><a href="#6-过滤消息" class="headerlink" title="6 过滤消息"></a>6 过滤消息</h3><p>主要是看消息消费者。consumer.subscribe(“TagFilterTest”, “TagA || TagC”); 这句只订阅TagA和TagC的消息。</p><p>TAG是RocketMQ中特有的一个消息属性。RocketMQ的最佳实践中就建议，使用RocketMQ时，一个应用可以就用一个Topic，而应用中的不同业务就用TAG来区分。</p><p>但是，这种方式有一个很大的限制，就是一个消息只能有一个TAG，这在一些比较复杂的场景就有点不足了。 这时候，可以使用SQL表达式来对消息进行过滤。</p><h3 id="7-事务消息"><a href="#7-事务消息" class="headerlink" title="7 事务消息"></a>7 事务消息</h3><p><strong>这个事务消息是RocketMQ提供的一个非常有特色的功能，需要着重理解</strong>。</p><p><strong>首先</strong>，我们了解下什么是事务消息。官网的介绍是：事务消息是在分布式系统中保证最终一致性的两阶段提交的消息实现。他可以<strong>保证本地事务执行与消息发送两个操作的原子性，也就是这两个操作一起成功或者一起失败。</strong></p><p><strong>其次</strong>，我们来理解下事务消息的编程模型。<strong>事务消息只保证消息发送者的本地事务与发消息这两个操作的原子性</strong>，因此，事务消息的示例只涉及到消息发送者，对于消息消费者来说，并没有什么特别的。</p><p>事务消息的关键是在TransactionMQProducer中指定了一个TransactionListener事务监听器，这个事务监听器就是事务消息的关键控制器。源码中的案例有点复杂，我这里准备了一个更清晰明了的事务监听器示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在执行sendMessageInTransaction方法的时候就会执行监听器的executeLocalTransaction方法，过了一段时间就会执行checkLocalTransaction方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"> <span class="comment">//在提交完事务消息后执行。</span></span><br><span class="line"> <span class="comment">//返回COMMIT_MESSAGE状态的消息会立即被消费者消费到。</span></span><br><span class="line"> <span class="comment">//返回ROLLBACK_MESSAGE状态的消息会被丢弃。</span></span><br><span class="line"> <span class="comment">//返回UNKNOWN状态的消息会由Broker过一段时间再来回查事务的状态。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> msg.getTags();</span><br><span class="line">        <span class="comment">//TagA的消息会立即被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        <span class="comment">//TagB的消息会被丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        <span class="comment">//其他消息会等待Broker进行事务状态回查。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//在对UNKNOWN状态的消息进行状态回查时执行。返回的结果是一样的。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> msg.getTags();</span><br><span class="line">        <span class="comment">//TagC的消息过一段时间会被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagC&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        <span class="comment">//TagD的消息也会在状态回查时被丢弃掉</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagD&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        <span class="comment">//剩下TagE的消息会在多次状态回查后最终丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务消息的实现机制：</p><p><img src="/RocketMQ%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.assets/image-20220602090841525.png" alt="image-20220602090841525"></p><p>事务消息机制的关键是在发送消息时，会将消息转为一个half半消息，并存入RocketMQ内部的一个 RMQ_SYS_TRANS_HALF_TOPIC 这个Topic，这样对消费者是不可见的。再经过一系列事务检查通过后，再将消息转存到目标Topic，这样对消费者就可见了。</p><blockquote><p>half消息对下游不可见</p></blockquote><p>实例解释：</p><p><img src="/RocketMQ%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.assets/image-20220602102252616.png" alt="image-20220602102252616"></p><p>​1.发送half消息给mq</p><p>​2.返回消息结果</p><p>​3.执行本地事务，向mq返回本地事务的状态。如果状态是commit的话事务就提交了，并把消息给下游服务去消费。如果是rollback状态就直接把食物丢弃。</p><p>​4.如果是unknow状态，mq就会过一段时间回查事务的状态。生产者就会去检查本地事务的状态。然后再向mq返回一个事务检查的状态。一直循环5，6，7。这里mq默认回查15次如果检查15次后状态还是未知最终就会确认事务的失败的。</p><p>​5.根据信息状态提交或回滚。</p><p>1.为什么要发送half消息？<br>在进行本地事务之前确定mq是否运行正常</p><p>2.half成功，执行本地事务失败怎么办？</p><p>​业务中需要赶紧阻止这个消息。这时候可以马上向mq返回一个rollback状态去回滚。</p><h3 id="8-ACL权限控制"><a href="#8-ACL权限控制" class="headerlink" title="8 ACL权限控制"></a>8 ACL权限控制</h3><p>​权限控制（ACL）主要为RocketMQ提供Topic资源级别的用户访问控制。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ安装</title>
      <link href="/2024/11/17/RocketMQ%E5%AE%89%E8%A3%85/"/>
      <url>/2024/11/17/RocketMQ%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="RocketMQ安装"><a href="#RocketMQ安装" class="headerlink" title="RocketMQ安装"></a>RocketMQ安装</h2><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>1.RocketMQ是使用Java语言编写的所以在安装该MQ前需要Java环境。</p><p>2.准备好RocketMQ</p><p>​RocketMQ运行版本下载地址： <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip</a></p><p>​RocketMQ源码版本下载地址： <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-source-release.zip">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-source-release.zip</a></p><h3 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h3><p>把下载的rocketmq-all-4.7.1-bin-release.zip在本地完成解压，并上传到&#x2F;app&#x2F;rocketmq目录。</p><p>把rocketmq的bin目录也配置到环境变量当中。 vi ~&#x2F;.bash_profile，加入以下内容，并执行source ~&#x2F;.bash_profile让环境变量生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ROCKETMQ_HOME=/app/rocketmq/rocketmq-all-4.7.1-bin-release</span><br></pre></td></tr></table></figure><p>这样RocketMQ就安装完成了。</p><h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><p>RocketMQ由以下这几个组件组成</p><ol><li>NameServer : 提供轻量级的Broker路由服务。</li><li>Broker：实际处理消息存储、转发等服务的核心组件。</li><li>Producer：消息生产者集群。通常是业务系统中的一个功能模块。</li><li>Consumer：消息消费者集群。通常也是业务系统中的一个功能模块。</li></ol><p>所以我们要启动RocketMQ服务，需要先启动NameServer。</p><h3 id="启动NameServer"><a href="#启动NameServer" class="headerlink" title="启动NameServer"></a><strong>启动NameServer</strong></h3><p>在$ROCKETMQ_HOME&#x2F;bin目录下有个mqadminsrv可以启动RocketMQ的NameServer服务。</p><blockquote><p>注意:RocketMQ默认预设的JVM内存是4G(最佳配置)。但是通常我们用虚拟机的话都是不够4G内存的，所以需要调整下JVM内存大小。修改的方式是直接修改安装目录下的bin目录中的runserver.sh。 用vi runserver.sh编辑这个脚本，在脚本中找到这一行调整内存大小为512M</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m - XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\QiJian\AppData\Roaming\Typora\typora-user-images\image-20220531093010948.png" alt="image-20220531093010948"></p><p>静默启动的方式启动NameServer服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup bin/mqnamesrv &amp;</span><br><span class="line">如果保存就使用：</span><br><span class="line">nohup bin/mqnamesrv &gt; nohup.out <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><blockquote><p>静默方式启动：不占用控制台，后台执行</p></blockquote><p><img src="C:\Users\QiJian\AppData\Roaming\Typora\typora-user-images\image-20220531101003247.png" alt="image-20220531101003247"></p><h3 id="启动Broker"><a href="#启动Broker" class="headerlink" title="启动Broker"></a><strong>启动Broker</strong></h3><p>启动Broker的脚本是runbroker.sh。Broker的默认预设内存是8G，启动前，如果内存不够，同样需要调整下JVM内存.(vi runbroker.sh)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span></span><br></pre></td></tr></table></figure><p>找到$ROCKETMQ_HOME&#x2F;conf&#x2F;broker.conf， vi指令进行编辑，在最下面加入一个配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoCreateTopicEnable=<span class="literal">true</span> #默认值是<span class="literal">true</span>，可以同步外部配置文件，让Broker启动时加载，来改变该值。</span><br></pre></td></tr></table></figure><p>静默启动的方式启动runbroker.sh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup ../bin/mqbroker &amp;</span><br><span class="line">或</span><br><span class="line">nohup ./bin/mqbroker &gt; nohup.out <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><h3 id="命令行快速验证"><a href="#命令行快速验证" class="headerlink" title="命令行快速验证"></a><strong>命令行快速验证</strong></h3><p>在RocketMQ的安装包中，提供了一个tools.sh工具可以用来在命令行快速验证RocketMQ服务。</p><p>首先需要配置一个环境变量NAMESRV_ADDR指向我们启动的NameServer服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_profile</span><br><span class="line">    </span><br><span class="line">export NAMESRV_ADDR=<span class="string">&#x27;localhost:9876&#x27;</span></span><br></pre></td></tr></table></figure><p>启动消息生产者发送消息：默认会发1000条消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure><p><img src="C:\Users\QiJian\AppData\Roaming\Typora\typora-user-images\image-20220531134231074.png" alt="image-20220531134231074"></p><p>启动消息消费者接收消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p><img src="C:\Users\QiJian\AppData\Roaming\Typora\typora-user-images\image-20220531134421318.png" alt="image-20220531134421318"></p><h3 id="关闭RocketMQ服务"><a href="#关闭RocketMQ服务" class="headerlink" title="关闭RocketMQ服务"></a><strong>关闭RocketMQ服务</strong></h3><p>要关闭RocketMQ服务可以通过mqshutdown脚本直接关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>关闭NameServer </span><br><span class="line">    sh bin/mqshutdown namesrv </span><br><span class="line"># <span class="number">2.</span>关闭Broker </span><br><span class="line">    sh bin/mqshutdown broker</span><br></pre></td></tr></table></figure><h3 id="搭建管理控制台"><a href="#搭建管理控制台" class="headerlink" title="搭建管理控制台"></a><strong>搭建管理控制台</strong></h3><p>地址： <a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p><p>下载下来后，进入其中的rocket-console目录，使用maven进行编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=localhost:<span class="number">9876</span></span><br></pre></td></tr></table></figure><h2 id="快速搭建RocketMQ集群"><a href="#快速搭建RocketMQ集群" class="headerlink" title="快速搭建RocketMQ集群"></a>快速搭建RocketMQ集群</h2><h3 id="1、机器环境"><a href="#1、机器环境" class="headerlink" title="1、机器环境"></a>1、机器环境</h3><p>准备三台机器，都进行如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">打开文件后追加：</span><br><span class="line"><span class="number">192.168</span><span class="number">.85</span><span class="number">.3</span> worker1</span><br><span class="line"><span class="number">192.168</span><span class="number">.85</span><span class="number">.4</span> worker2</span><br><span class="line"><span class="number">192.168</span><span class="number">.85</span><span class="number">.5</span> worker3</span><br></pre></td></tr></table></figure><h3 id="2、创建用户"><a href="#2、创建用户" class="headerlink" title="2、创建用户"></a>2、创建用户</h3><p>useradd oper</p><p>passwd oper (密码输入 123qweasd)</p><h3 id="3、系统配置"><a href="#3、系统配置" class="headerlink" title="3、系统配置"></a>3、系统配置</h3><h4 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h4><p>切换oper用户，在worker1上 生成key</p><p>ssh-kengen</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后分发给其他机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id worker1</span><br><span class="line">ssh-copy-id worker2</span><br><span class="line">ssh-copy-id worker3</span><br><span class="line"></span><br><span class="line">登入其他机器只需要</span><br><span class="line">ssh worker2</span><br><span class="line">退出</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">firewall-cmd --state </span><br></pre></td></tr></table></figure><h3 id="4、配置RocketMQ集群"><a href="#4、配置RocketMQ集群" class="headerlink" title="4、配置RocketMQ集群"></a>4、配置RocketMQ集群</h3><p>为了便于观察，这次搭建一个2主2从异步刷盘的集群，所以我们会使用conf&#x2F;2m-2s-async下的配置文件，实际项目中，为了达到高可用，一般会使用dleger。预备设计的集群情况如下：</p><table><thead><tr><th>机器名</th><th>nemaeServer节点部署</th><th>broker节点部署</th></tr></thead><tbody><tr><td>worker1</td><td>nameserver</td><td></td></tr><tr><td>worker2</td><td>nameserver</td><td>broker-a, broker-b-s</td></tr><tr><td>worker3</td><td>nameserver</td><td>broker-b,broker-a-s</td></tr></tbody></table><p>所以修改的配置文件是进入rocketmq的config目录下修改2m-2s-async的配置文件。–只需要配置broker.conf。</p><blockquote><p>在rocketmq的config目录下可以看到rocketmq建议的各种配置方式：</p><ul><li>2m-2s-async: 2主2从异步刷盘(吞吐量较大，但是消息可能丢失),</li><li>2m-2s-sync:2主2从同步刷盘(吞吐量会下降，但是消息更安全)，</li><li>2m-noslave:2主无从(单点故障)，然后还可以直接配置broker.conf，进行单点环境配置。</li><li>而dleger就是用来实现主从切换的。集群中的节点会基于Raft协议随机选举出一个leader，其他的就都是follower。通常正式环境都会采用这种方式来搭建集群。</li></ul></blockquote><p>我们这次采用2m-2s-async的方式搭建集群。</p><h3 id="5、配置第一组broker-a"><a href="#5、配置第一组broker-a" class="headerlink" title="5、配置第一组broker-a"></a>5、配置第一组broker-a</h3><p>在<strong>worker2</strong>上先配置borker-a的master节点。先配置2m-2s-async&#x2F;broker-a.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字，名字一样的节点就在同一个集群内</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，名字一样的节点就是一组主从节点。</span><br><span class="line">brokerName=broker-a</span><br><span class="line">#brokerid,<span class="number">0</span>就表示是Master，&gt;<span class="number">0</span>的都是表示 Slave</span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=<span class="number">10911</span></span><br><span class="line">#删除文件时间点，默认凌晨 <span class="number">4</span>点</span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">#文件保留时间，默认 <span class="number">48</span> 小时</span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line">#destroyMapedFileIntervalForcibly=<span class="number">120000</span></span><br><span class="line">#redeleteHangedFileInterval=<span class="number">120000</span></span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/app/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/app/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/app/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/app/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/app/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/app/rocketmq/store/abort</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line">#flushCommitLogLeastPages=<span class="number">4</span></span><br><span class="line">#flushConsumeQueueLeastPages=<span class="number">2</span></span><br><span class="line">#flushCommitLogThoroughInterval=<span class="number">10000</span></span><br><span class="line">#flushConsumeQueueThoroughInterval=<span class="number">60000</span></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">#checkTransactionMessageEnable=<span class="literal">false</span></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=<span class="number">128</span></span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=<span class="number">128</span></span><br></pre></td></tr></table></figure><p>该节点对应的从节点在<strong>worker3</strong>上。修改2m-2s-async&#x2F;broker-a-s.properties <code>只需要修改brokerId和brokerRole</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字，名字一样的节点就在同一个集群内</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，名字一样的节点就是一组主从节点。</span><br><span class="line">brokerName=broker-a</span><br><span class="line">#brokerid,<span class="number">0</span>就表示是Master，&gt;<span class="number">0</span>的都是表示 Slave</span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=<span class="number">11011</span></span><br><span class="line">#删除文件时间点，默认凌晨 <span class="number">4</span>点</span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">#文件保留时间，默认 <span class="number">48</span> 小时</span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line">#destroyMapedFileIntervalForcibly=<span class="number">120000</span></span><br><span class="line">#redeleteHangedFileInterval=<span class="number">120000</span></span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/app/rocketmq/storeSlave</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/app/rocketmq/storeSlave/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/app/rocketmq/storeSlave/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/app/rocketmq/storeSlave/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/app/rocketmq/storeSlave/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/app/rocketmq/storeSlave/abort</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line">#flushCommitLogLeastPages=<span class="number">4</span></span><br><span class="line">#flushConsumeQueueLeastPages=<span class="number">2</span></span><br><span class="line">#flushCommitLogThoroughInterval=<span class="number">10000</span></span><br><span class="line">#flushConsumeQueueThoroughInterval=<span class="number">60000</span></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">#checkTransactionMessageEnable=<span class="literal">false</span></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=<span class="number">128</span></span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=<span class="number">128</span></span><br></pre></td></tr></table></figure><h3 id="3、配置第二组Broker-b"><a href="#3、配置第二组Broker-b" class="headerlink" title="3、配置第二组Broker-b"></a>3、配置第二组Broker-b</h3><p>这一组broker的主节点在<strong>worker3</strong>上，所以需要配置worker3上的config&#x2F;2m-2s-async&#x2F;broker-b.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字，名字一样的节点就在同一个集群内</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，名字一样的节点就是一组主从节点。</span><br><span class="line">brokerName=broker-b</span><br><span class="line">#brokerid,0就表示是Master，&gt;0的都是表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=worker1:9876;worker2:9876;worker3:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/app/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/app/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/app/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/app/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/app/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/app/rocketmq/store/abort</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure><p>然后在对应的slave在worker2上，修改work2上的 conf&#x2F;2m-2s-async&#x2F;broker-b-s.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字，名字一样的节点就在同一个集群内</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，名字一样的节点就是一组主从节点。</span><br><span class="line">brokerName=broker-b</span><br><span class="line">#brokerid,<span class="number">0</span>就表示是Master，&gt;<span class="number">0</span>的都是表示 Slave</span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=<span class="number">11011</span></span><br><span class="line">#删除文件时间点，默认凌晨 <span class="number">4</span>点</span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">#文件保留时间，默认 <span class="number">48</span> 小时</span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line">#destroyMapedFileIntervalForcibly=<span class="number">120000</span></span><br><span class="line">#redeleteHangedFileInterval=<span class="number">120000</span></span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/app/rocketmq/storeSlave</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/app/rocketmq/storeSlave/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/app/rocketmq/storeSlave/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/app/rocketmq/storeSlave/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/app/rocketmq/storeSlave/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/app/rocketmq/storeSlave/abort</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line">#flushCommitLogLeastPages=<span class="number">4</span></span><br><span class="line">#flushConsumeQueueLeastPages=<span class="number">2</span></span><br><span class="line">#flushCommitLogThoroughInterval=<span class="number">10000</span></span><br><span class="line">#flushConsumeQueueThoroughInterval=<span class="number">60000</span></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">#checkTransactionMessageEnable=<span class="literal">false</span></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=<span class="number">128</span></span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=<span class="number">128</span></span><br></pre></td></tr></table></figure><p>这样broker就配置完成了。</p><blockquote><p>需要注意的配置项：</p><p>1、同一机器上两个实例的store目录不能相同，否则会报错 Lock failed,MQ already started</p><p>2、同一机器上两个实例的listenPort也不能相同。否则会报端口占用的错nameserver不需要进行配置，直接启动就行。这也看出nameserver是无状态的。</p></blockquote><h3 id="7、启动RocketMQ"><a href="#7、启动RocketMQ" class="headerlink" title="7、启动RocketMQ"></a>7、启动RocketMQ</h3><h4 id="1、先启动nameServer"><a href="#1、先启动nameServer" class="headerlink" title="1、先启动nameServer"></a>1、先启动nameServer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure><h4 id="2、再启动broker"><a href="#2、再启动broker" class="headerlink" title="2、再启动broker"></a>2、再启动broker</h4><p>在<strong>worker2</strong>上启动broker-a的master节点和broker-b的slave节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-a.properties &amp;</span><br><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure><p>在work3上启动broker-b的master节点和broker-a的slave节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-b.properties &amp;</span><br><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="3、启动状态检查"><a href="#3、启动状态检查" class="headerlink" title="3、启动状态检查"></a>3、启动状态检查</h4><p>jps指令，能看到一个NameSrvStartup进程和两个BrokerStartup进程。</p><p>nohup.out中也有启动成功的日志。</p><p>对应的日志文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nameServer日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看broker日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><h4 id="4、命令行快速验证"><a href="#4、命令行快速验证" class="headerlink" title="4、命令行快速验证"></a>4、命令行快速验证</h4><p>三台服务器都配置上如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">export NAMESRV_ADDR=&#x27;worker1:9876;worker2:9876;worker3:9876&#x27;</span><br><span class="line"></span><br><span class="line">source  ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="8-测试mqadmin管理工具"><a href="#8-测试mqadmin管理工具" class="headerlink" title="8,测试mqadmin管理工具"></a>8,测试mqadmin管理工具</h3><p>地址： <a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p><p>下载下来后，进入其中的rocket-console目录，使用maven进行编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean <span class="keyword">package</span> -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上传至服务器，jar包的当前目录下增加一个application.properties文件，覆盖jar包中默认的一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=worker1:9876;worker2:9876;worker3:9876</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.1.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过zookeeper浅谈一致性算法</title>
      <link href="/2024/11/17/%E9%80%9A%E8%BF%87zookeeper%E6%B5%85%E8%B0%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/17/%E9%80%9A%E8%BF%87zookeeper%E6%B5%85%E8%B0%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="通过zookeeper浅谈一致性算法"><a href="#通过zookeeper浅谈一致性算法" class="headerlink" title="通过zookeeper浅谈一致性算法"></a>通过zookeeper浅谈一致性算法</h1><h2 id="CAP定理介绍"><a href="#CAP定理介绍" class="headerlink" title="CAP定理介绍"></a>CAP定理介绍</h2><p>CAP 定理指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。</p><blockquote><p>通俗来说：</p><p>一致性（C）：当系统数据发生更新操作后，各个主机中的数据仍然处于一致的状态。</p><p>可用性（A）：对于用户的每一个请求，系统总是可以在有限的时间内对用户做出响应。</p><p>分区容错性（P）：分布式系统在遇到任何网络分区故障时，仍能够保证对外提供满足一致性或可用性的服务。</p></blockquote><p>​对于分布式系统来说，网络🛜环境是相对不可控制的，出现网络分区是不可避免的。网络分区的出现很可能就会带来脑裂问题（例如：机房之间的网络通信出现故障），这就会导致集群分裂成两个或多个，它们都认为只有自己没有崩溃，都可以独立运行。对于zk这分布式协调系统来说，数据的一致性是基本的要求，它需要保证在任何时刻访问都能得到一致性的数据结果，所以分区容错性是需要保证的。zk默认是通过<strong>“过半机制”</strong>防止脑裂的。</p><p>​不难发现，一致性和可用性是不能同时保证的。原因：数据同步是需要时间的，在同步的期间，若允许client访问，则client从不同节点读取到的数据就可能是不同的（牺牲了一致性保证了可用性）。若不允许client访问，则client在同步期间无法获取服务，但是在同步后无论访问哪个节点读取的数据都会是一样的（牺牲了可用性从而保证一致性）。</p><blockquote><p>网络分区是指在分布式系统中，由于网络故障、节点故障等原因，导致集群中的节点被分割成多个独立的子集，每个子集之间无法进行通信的现象。网络分区会导致分布式系统的可用性和一致性受到影响，因此需要采取一定的措施来避免或解决网络分区问题。</p></blockquote><h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a><strong>BASE</strong> <strong>理论</strong></h2><p>​BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写，BASE 是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于 CAP 定理逐步演化而来的。</p><p>BASE 理论的核心思想是：<strong>即使无法做到强一致性，但每个系统都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</strong></p><p>1.基本可用：分布式系统出现不可预知故障的时候，允许损失部分可用性。体现在：响应时间上的损失  和 功能上的损失（服务降级）。</p><p>2.软状态：允许系统数据存在的中间状态，并认为该中间状态的存在不会影响系统的整体可用性。例如允许zk之间的数据同步存在一定的数据延迟。</p><p>3.最终一致性：强调所有的数据副本在经过一段时间后，<strong>最终</strong>能够达到一个一致性的状态。</p><h2 id="从zk的角度谈cp"><a href="#从zk的角度谈cp" class="headerlink" title="从zk的角度谈cp"></a>从zk的角度谈cp</h2><p>​在zk集群中，leader节点宕机后，整个集群会有一段时间是不能被访问的，后面又可以访问了。在这段不可访问的时间内，zk集群是在做leader选举，期间是不接受客户端的读写操作的。也可以这么理解在leader选举期间，zk集群是处于瘫痪期间的，同步完毕后读取到的数据是一致性的数据。满足了一致性，牺牲了一定的可用性。</p><h2 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h2><p>​通俗来说，分布式事务是将多个操作组成一个事务来完成，并且这多个操作要么一起成功，要么一起失败。这个很有名的一个处理分布式事务的组件就是阿里的seats。一般分布式一致性是由分布式事务实现的，需要保证客户端从分布式系统中的每一个server节点获取的数据，在某一段时间是可以保证是一致的（最终一致性）。</p><p>2PC算法：每一个server对本地事务的确认，需要经历两个阶段，prepare阶段和commit阶段。在MySQL中通过2pc保证<strong>Redo和Binlog的保持一致</strong>。1）当事务提交时InnoDB存储引擎进行prepare操作，将数据写入到binglog日志中。2）InnoDB存储引擎将事务写入到Redo Log文件中。在seata的事务模式中XA，AT，TCC都是2PC的。</p><p>3PC算法：在2PC的基础上新增一个Accept阶段（提交指令阶段）。该阶段主要是事务协调者（TC）向资源管理者（RM）发送accept指令，RM收到指令后判断是否可以完成自己的事物并且将判断结果给TC。</p><p>Paxos算法：该算法要解决的问题是在分布式系统中如何就某个决议达成一致。ZAB（Zookeeper Atomic Broadcast）协议是Paxos算法的一种工业实现。在zookeeper中使用一个单一主进程来接收并处理客户端的所有请求（写请求）,当数据发生变更，ZAB采用原子广播协议，以事务提案 Proposal 的形式广播到所有的副本进程上并且为每一个事务分配一个全局递增的编号Xid.  客户端连接到一个z k集群后，如果是读请求,那么当前节点就会根据自己保存的数据对其进行相应数据返回。如果是写请求并且不是leader节点，那么当前节点就会首先将请求转发给leader节点，leader节点以提案的方式广播该写操作，只有超过<strong>过半的节点同意该写操作该写请求才会被提交</strong>，然后leader广播给所有的follower节点，通知它们同步数据。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL阻塞与死锁</title>
      <link href="/2024/11/17/MySQL%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
      <url>/2024/11/17/MySQL%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL阻塞与死锁"><a href="#MySQL阻塞与死锁" class="headerlink" title="MySQL阻塞与死锁"></a>MySQL阻塞与死锁</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看等待时间</span><br><span class="line">show variables like &#x27;innodb_lock_wait_timeout&#x27;;</span><br><span class="line">SET@@innodb_lock_wait_timeout=60;</span><br><span class="line"># 是否在等待超时时对进行中的事务进行回滚操作</span><br><span class="line">show variables like &#x27;innodb_rollback_on_timeout&#x27;;</span><br><span class="line"></span><br><span class="line">#设置等待时间  默认50秒</span><br><span class="line">SET@@innodb_lock_wait_timeout=60;  </span><br><span class="line">#设置是否在等待超时时对进行中的事务进行回滚操作  默认是OFF 代表不回滚</span><br><span class="line">SET@@innodb_rollback_on_timeout=on;</span><br></pre></td></tr></table></figure><p>查询：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%BE1%EF%BC%89.png" alt="image-20230814102157758"></p><p>设置值：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%BE2%EF%BC%89.png" alt="image-20230815165901211"></p><p>注意：参数<code>innodb_lock_wait_timeout</code> 参数是动态的，在mysql运行时可进行调整，<code>innodb_rollback_on_timeout</code>参数是静态的，不可在运行时进行修改，否则会报错。</p><p>需要特别注意：<strong>在默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。</strong>（其实InnoDB存储引擎在大部分情况下都不会对异常进行回滚。）</p><p>异常实例演示：</p><p>左边为会话A，右边为会话B。初始状态数据库表film中有3条数据，ID，分别为3，5，6；</p><p>首先会话A 开启了事务A，并且在Next-Key Lock算法下锁定了小与5包含5的记录。事务B正常插入记录ID:7，当插入ID:4 时就进人阻塞状态了</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%BE%E4%B8%89%EF%BC%89.png" alt="image-20230815174128914"></p><p>当事务B达到事务超时间时间时，报错<code>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</code>.</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%BE%E5%9B%9B%EF%BC%89.png" alt="image-20230815174608612"></p><p>这时事务B在此查询会发现，<strong>ID:7 这条记录依然存在，这是因为事务B虽然抛出了异常，但是既没有进行commit 操作也没有进行 rollback操作。</strong>这是非常危险的，因为此时数据库一致性特性被打破了。因此此时用户必须判断是否需要COMMIT还是ROLLBACK，之后再进行下一步的操作。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%BE%E4%BA%94%EF%BC%89.png" alt="image-20230815175103979"></p><p>一般情况这时事务B需要进行 rollback操作，具体情况具体分析。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%BE%E5%85%AD%EF%BC%89.png" alt="image-20230815175620413"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。</p><p>当发生死锁的时候，若无外力作用事务都将无法进行下去。</p><blockquote><p>死锁产生的条件：</p><ul><li>互斥条件<br>临界资源是独占资源，进程应互斥且排他的使用这些资源。</li><li>占有和等待条件<br>进程在请求资源得不到满足而等待时，不释放已占有资源。</li><li>不剥夺条件<br>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</li><li>循环等待条件<br>又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</li></ul></blockquote><p>如何解决死锁问题：</p><p>1.超时机制：当两个事务互相等待时，如果等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。在InnoDB存储引擎中，<code>innodb_lock_wait_timeout</code>设置超时的时间。</p><p>我们知道，一条记录是有很多undo log的或者undo 版本链有很多版本的，如果一个事务操作更新了很多行，这时候如果要进行回滚所占用的时间可能就会很多。</p><p>2.使用wai t-for graph （等待图）进行死锁检测，数据库需要保存锁的信息链表和事务等待链表。我们通过锁的信息链表和事务等待链表就可以构造出一张图，如果图中存在回路那就说明出现了死锁。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81_%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%BE%E4%B8%83%EF%BC%89.png" alt="image-20230815235528149"></p><p>​事务和锁状态图</p><p>上图中，transaction wait list 中有四个事务，事务t2对row1加了x锁，事务t1对row1加了s锁，并且事务t1需要等待事务t2中的row1资源，因此wait-for graph图中有一条边冲节点t1指向t2。 row2记录的情况同理。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E9%94%81%20wait-%20for%20graph%EF%BC%88%E5%9B%BE%E5%85%AB%EF%BC%89.png" alt="image-20230816001239711"></p><p>​wait-for graph</p><p>观察发现，t1 和 t2 存在回路，因此存在死锁。</p><blockquote><p>阅读到这里，我们需要意识到因为MySQL数据库是一个并发的程序，所以才存在死锁。因为如果程序是串行的，那么也就不会发生死锁了。</p></blockquote><p>死锁示例：</p><p>有两个事务A，B： 事务A当前读查询记录ID:5 ,事务B当前读查询ID:6。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B%EF%BC%881%EF%BC%89.png" alt="image-20230816002539299"></p><p>接着交换一下：</p><p>事务A当前读查询记录ID:6 ,事务B当前读查询ID:5</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B%EF%BC%882%EF%BC%89.png" alt="image-20230816003007483"></p><p>会发现两个事务中的事务B立马就报错：<code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></p><p><strong>通常来说InnoDB存储引擎选择回滚undo量最小的事务。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL 深入学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁机制</title>
      <link href="/2024/11/17/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/11/17/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL中的锁机制"><a href="#MySQL中的锁机制" class="headerlink" title="MySQL中的锁机制"></a>MySQL中的锁机制</h1><blockquote><p>抛砖引玉：多个查询需要在同一时刻进行数据的修改，就会产生并发控制的问题。我们需要如何避免写个问题从而保证我们的数据库数据不会被破坏。</p></blockquote><h2 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h2><p>读锁是共享的互相不阻塞的。多个事务在听一时刻可以同时读取同一资源，而相互不干扰。</p><p>写锁的排他的。一个写锁会阻塞其他写锁或读锁。出于安全考虑只有这样才能保证在给定的时间里只有一个事务能够执行写入，并防止其他事务读取正写入的同一资源。</p><h2 id="锁带来的问题"><a href="#锁带来的问题" class="headerlink" title="锁带来的问题"></a>锁带来的问题</h2><p>通过锁定机制可以实现事务的隔离性要求，使得事务可以并发的工作，同时也带来了三个问题：脏读，不可重复读和丢失更新。</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><blockquote><p>脏数据：未提交的数据</p></blockquote><p>如果读到了脏数据即一个事务可以读取到另一个事务中未提交的数据那就违背了事务的隔离性。</p><p>所以脏读是指在不同的事务下，当前事务可以读取到另外事务的未提交的数据，简单来说就是可以读取到脏数据。</p><p>演示：</p><p>初始状态：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE1).png" alt="image-20230813233401790"></p><p>将会话A，B设置隔离级别为RU</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level READ UNCOMMITTED;</span><br></pre></td></tr></table></figure><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE2).png" alt="image-20230813235156382"></p><p>会话A插入一条数据</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE3).png" alt="image-20230814000655870"></p><p>这时候事务B在此执行查询操作，会发现事务B读取到了事务A新增的数据。注意：此时事务A没有提交。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE4).png" alt="image-20230814000932266"></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务中两次读取到的数据是不一样的，这中情况被称为不可重复读。</p><p>与脏读的区别：脏读是读取到了未提交的数据，而不可重复读是读取到的却是已经提交的数据，但是违反了数据库事务一致性的要求。</p><p>演示：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE5).png" alt="image-20230814002516720"></p><p>事务B插入一条数据并且提交</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE6).png" alt="image-20230814002726465"></p><p>事务A在此执行select语句,事务A读取到了事务B提交的数据</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E9%94%81%E6%9C%BA%E5%88%B6(%E5%9B%BE7).png" alt="image-20230814002910671"></p><p>一般来说不可重复读问题是可以接受的，因为读取到的是已经提交的数据，本身不会带来什么问题。例如Oracle 和 SQL Server的默认的事务隔离级别就是RC。 MySQL默认的事务隔离级别是RR。</p><p><strong>在MySQL InnoDB中通过使用 Next-key lock 算法来避免不可重复读问题，并且将不可重复读问题定义为幻读（Phantom problem）</strong></p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>一个数据的更新会被另一个事务的更新操作所覆盖，从而导致数据的不一致性。</p><p>第一种丢失：</p><p>A事务撤销时，把已经提交的B事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来：</p><table><thead><tr><th>时间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td>T1</td><td><strong>开始事务</strong></td><td></td></tr><tr><td>T2</td><td></td><td><strong>开始事务</strong></td></tr><tr><td>T3</td><td>查询账户余额为1000元</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为1000元</td></tr><tr><td>T5</td><td></td><td>汇入100元把余额改为1100元</td></tr><tr><td>T6</td><td></td><td><strong>提交事务</strong></td></tr><tr><td>T7</td><td>取出100元把余额改为900元</td><td></td></tr><tr><td>T8</td><td><strong>撤销事务</strong></td><td></td></tr><tr><td>T9</td><td><strong>余额恢复为1000</strong> <strong>元（丢失更新）</strong></td><td></td></tr></tbody></table><p>第二类丢失更新</p><p>A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失：</p><table><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td>T1</td><td></td><td><strong>开始事务</strong></td></tr><tr><td>T2</td><td><strong>开始事务</strong></td><td></td></tr><tr><td>T3</td><td></td><td>查询账户余额为1000元</td></tr><tr><td>T4</td><td>查询账户余额为1000元</td><td></td></tr><tr><td>T5</td><td></td><td>取出100元把余额改为900元</td></tr><tr><td>T6</td><td></td><td><strong>提交事务</strong></td></tr><tr><td>T7</td><td>汇入100元</td><td></td></tr><tr><td>T8</td><td><strong>提交事务</strong></td><td></td></tr><tr><td>T9</td><td><strong>把余额改为1100</strong> <strong>元（丢失更新）</strong></td><td></td></tr></tbody></table><p>要避免丢失更新的发生，需要让事务在这种情况的操作变成串行化，而不是并行操作。即上面的select操作中加上排他锁。</p><h2 id="MySQL锁的分类："><a href="#MySQL锁的分类：" class="headerlink" title="MySQL锁的分类："></a>MySQL锁的分类：</h2><h3 id="按照锁的粒度来说"><a href="#按照锁的粒度来说" class="headerlink" title="按照锁的粒度来说"></a>按照锁的粒度来说</h3><p>MySQL主要包含三种类型（级别）的锁定机制：</p><p>全局锁：锁的是整个database。</p><p>表级锁：锁的是某个table。 (表排他锁，表共享锁，元数据锁，自增锁)</p><p>行级锁：锁的是某行数据，也可能锁定行之间的间隙。由某些存储引擎实现，比如InnoDB。</p><h3 id="InnoDB的行级锁，按照锁定范围来说"><a href="#InnoDB的行级锁，按照锁定范围来说" class="headerlink" title="InnoDB的行级锁，按照锁定范围来说"></a>InnoDB的行级锁，按照锁定范围来说</h3><p>分为四种：</p><p>1.记录锁（Record Locks）:锁定索引中一条记录。</p><p>2.间隙锁（Gap Locks）:要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或者最后一个索</p><p>引记录后面的值。</p><p>3.临键锁（Next-Key Locks）:是索引记录上的记录锁和在索引记录之前的间隙锁的组合（间隙锁+记录</p><p>锁）。</p><p>4.插入意向锁(Insert Intention Locks)：做insert操作时添加的对记录id的锁。</p><h3 id="InnoDB的行级锁，按照功能来说"><a href="#InnoDB的行级锁，按照功能来说" class="headerlink" title="InnoDB的行级锁，按照功能来说"></a>InnoDB的行级锁，按照功能来说</h3><p>分为两种：</p><p>1.共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p><p>2.排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过</p><p>索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p><blockquote><p>注意：插入意向锁</p><p>（1）插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p><p>（2）在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等 待。</p><p>（3）假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之 间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p><p>（4）插入意向锁不会阻止任何锁，对于插入的记录会持有一个记录锁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL 深入学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL幻读问题</title>
      <link href="/2024/11/17/MYSQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2024/11/17/MYSQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL幻读问题"><a href="#MYSQL幻读问题" class="headerlink" title="MYSQL幻读问题"></a>MYSQL幻读问题</h1><h2 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h2><blockquote><p> “Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。”摘录来自 MySQL技术内幕：InnoDB存储引擎(第2版) (数据库技术丛书)</p></blockquote><p>​ 通俗来说就是，time1:事务A读取某个范围，time2:事务B在这个范围中插入了一条新记录并提交事务，time3:事务A再次读取该范围的记录时读取到事务B新增的记录。</p><p>如下：</p><p>目前InnoDB存储引擎中，数据库有表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for film</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `film`;</span><br><span class="line">CREATE TABLE `film` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of film</span><br><span class="line">-- ----------------------------</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO `film` (`id`, `name`) VALUES (1, &#x27;film1&#x27;);</span><br><span class="line">INSERT INTO `film` (`id`, `name`) VALUES (2, &#x27;film2&#x27;);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>Time1: 开启事务A ， 查询表film中的所有记录。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/mysql%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98_%E5%9B%BE%E4%B8%80.png" alt="image-20230813021444925"></p><p>Time2:在film表中插入一条ID 为 3的记录</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/MySQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98_%E5%9B%BE%E4%BA%8C.png" alt="image-20230813022134189"></p><p>Time3:  事务A查询表film中所有的数据；注意这时select出的记录中是没有ID为3的记录。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/MySQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98_%E5%9B%BE%E4%B8%89.png"></p><p>但是我们会发现update ID 为3的记录是成功的，也就是说事务A是可以感知到事务B新增的ID为3的记录。</p><p><img src="/./MYSQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.assets/MySQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98_%E5%9B%BE%E5%9B%9B.png" alt="image-20230813023334007"></p><p>这时再去读区数据发现是可以读取到的</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/MySQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98_%E5%9B%BE%E5%9B%9B.png" alt="image-20230813023520771"></p><p>这就是幻读问题。</p><h2 id="如何避免幻读问题？"><a href="#如何避免幻读问题？" class="headerlink" title="如何避免幻读问题？"></a>如何避免幻读问题？</h2><p>在RR级别下，采用Next-Key Locking的算法避免幻读问题，即使用FOR UPDATE。</p><blockquote><p>SELECT * FROM film  FOR UPDATE;</p></blockquote><p>对于上面的SQL语句，会将（-∞，+∞）这个范围加锁，因此在这个范围内的插入都是不允许的，从而避免幻读。当然如果是id &gt; 2 范围查找那么锁住的也就是(2,+∞)。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL 深入学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程（一）</title>
      <link href="/2024/11/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/11/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发编程（一）"><a href="#Java-并发编程（一）" class="headerlink" title="Java 并发编程（一）"></a>Java 并发编程（一）</h1><h2 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程：进程指正在运行的程序，进程拥有一个完整的、私有的基本运行资源集合。通常，每个进程都有自己的内存空间。</p><p>线程：有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。</p><blockquote><p>Java 并发编程之美中如下描述进程与线程：</p><p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p></blockquote><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411161529037.png" alt="image-20241116152919659"></p><p>当启动main函数的时候其实就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，这个线程是主线程。</p><p>图中可以看到，一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈区域。</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><blockquote><p>注意不管是并发还是并行都是以求最大化CUP的使用率。</p></blockquote><p><strong>并行(parallel)<strong>：</strong>指在同一时刻，有多条指令在多个处理器上同时执行</strong>。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411161457201.png" alt="image-20241116145727100"></p><p>**并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202411161510634.png" alt="image-20241116151017272"></p><h2 id="2、线程的创建"><a href="#2、线程的创建" class="headerlink" title="2、线程的创建"></a>2、线程的创建</h2><h4 id="方式1：使用-Thread类或继承Thread类"><a href="#方式1：使用-Thread类或继承Thread类" class="headerlink" title="方式1：使用 Thread类或继承Thread类"></a><strong>方式1：使用 Thread类或继承Thread类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象 </span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="comment">// 要执行的任务 </span></span><br><span class="line">  &#125; &#125;;</span><br><span class="line"><span class="comment">// 启动线程 </span></span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">  </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName())).start(); </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是：调用start()方法后线程没有立马执行，而是处于就绪状态。这个状态是指该线程已经获得了除CPU资源外的其他资源，等待获取cpu资源才会正真处于运行状态。一旦run()方法执行完毕，该线程就处于终止状态。</p><p>区别：</p><p>使用继承的好处是：在run()方法内获取当前线程直接使用this就可以了，无需使用Thread.currentThread()方法。不好的地方是Java不支持多继承，如果继承了Thread类，那么久不能再继承其他类。</p><p>存在问题：</p><p>任务与代码没有分离，当多个线程执行一样的任务代码时需要多分任务代码。</p></blockquote><h4 id="方式2：实现-Runnable-接口配合Thread"><a href="#方式2：实现-Runnable-接口配合Thread" class="headerlink" title="方式2：实现 Runnable 接口配合Thread"></a><strong>方式2：实现 Runnable 接口配合Thread</strong></h4><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="comment">// 要执行的任务 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 创建线程对象 </span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable ); <span class="comment">// 启动线程 </span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p><strong>存在的问题：</strong></p><p><strong>Runnable没有返回值：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有抛出异常：需要自己手动抛异常</p><p>Callable可以解决上面的问题</p><h4 id="方式3：使用有返回值的-Callable"><a href="#方式3：使用有返回值的-Callable" class="headerlink" title="方式3：使用有返回值的 Callable"></a><strong>方式3：使用有返回值的 Callable</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;callable come in ...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="comment">//创建FutureTask类，接受MyThread。</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br><span class="line">        <span class="comment">//将FutureTask对象放到Thread类的构造器里面。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result01</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//用FutureTask的get方法得到返回值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result02</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span> + (result01 + result02));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二</span></span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span> +  result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>小结：</p><p>使用继承的方式是方便传承，你可以在类里面添加成员变量，通过set方法设置参数或通过构造函数进行传参。不好的地方是Java不支持多基础，如果继承了Thread类，那么子类就不能再继承其他类而Runnable则没有这个限制。</p><p>如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。</p><p>前两个方式都没有办法拿到任务的返回结果，但是Callable方式可以</p></blockquote><h2 id="3、线程并发基础"><a href="#3、线程并发基础" class="headerlink" title="3、线程并发基础"></a>3、线程并发基础</h2><h4 id="3-1-wait-方法"><a href="#3-1-wait-方法" class="headerlink" title="3.1 wait() 方法"></a>3.1 wait() 方法</h4><p>当一个线程调用一个共享变量的wait()方法时，该调用线程会被<strong>阻塞</strong>挂起，直到发现下面几个事情之一才返回：</p><p>（1）其他线程调用了该共享对象的notify()或者notifyAll()方法。</p><p>（2）其他线程调用了该线程的interrupt()方法，该线程抛出InterruptedExecption异常返回</p><p>另外值得注意的是，如果调用wait()方法的线程没有事先获得该对象的监视器锁，则调用wait()方法时调用线程会抛出&#x3D;&#x3D;IllegalMonitorStateException&#x3D;&#x3D;异常</p><p>一个线程如何获取一个共享变量的监视器锁？</p><p>1、执行synchronized同步代码块，使用该共享变量作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (共享变量) &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、调用该共享锁变量的方法，并且该方法使用了synchronized修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123; </span><br><span class="line">  <span class="comment">//do someThing  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-wait-long-timeout"><a href="#3-2-wait-long-timeout" class="headerlink" title="3.2 wait(long timeout)"></a>3.2 wait(long timeout)</h4><p>​如果将timeout设置为0则和wait方法效果一样，因为在wait方法内部就是调用了wait（0）。需要注意的是，如果在调用该函数时，传递了一个负的timeout则会抛出IllegalArgumentException异常</p><h4 id="3-3-notify-函数"><a href="#3-3-notify-函数" class="headerlink" title="3.3 notify() 函数"></a>3.3 notify() 函数</h4><p>​一个线程调用共享对象的notify（）方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</p><h4 id="3-4-notifyAll-函数"><a href="#3-4-notifyAll-函数" class="headerlink" title="3.4 notifyAll() 函数"></a>3.4 notifyAll() 函数</h4><p>​不同于在共享变量上调用notify（）函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll（）方法则会唤醒所有在该共享变量上由于调用wait系列方法而被挂起的线程</p><h4 id="3-5-等待线程执行终止的join方法"><a href="#3-5-等待线程执行终止的join方法" class="headerlink" title="3.5 等待线程执行终止的join方法"></a>3.5 等待线程执行终止的join方法</h4><p>​等待调用join方法的线程结束之后，程序再继续执行，一般用于等待异步线程执行完结果之后才能继续运行的场景。</p><h4 id="3-6-yield方法"><a href="#3-6-yield方法" class="headerlink" title="3.6 yield方法"></a>3.6 <strong>yield方法</strong></h4><ul><li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li><li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li><li>具体的实现依赖于操作系统的任务调度器</li></ul><h4 id="3-7-sleep方法"><a href="#3-7-sleep方法" class="headerlink" title="3.7 sleep方法"></a>3.7 <strong>sleep方法</strong></h4><ul><li>调用 sleep 会让当前线程从 <em>Running</em> 进入TIMED_WAITING状态，不会释放对象锁</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException，并且会清除中断标志</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>sleep当传入参数为0时，和yield相同</li></ul><h4 id="3-8-stop方法-停止线并且释放锁"><a href="#3-8-stop方法-停止线并且释放锁" class="headerlink" title="3.8 stop方法(停止线并且释放锁)"></a>3.8 <strong>stop方法(停止线并且释放锁)</strong></h4><p>stop()方法已经被jdk废弃，原因就是stop()方法太过于暴力，强行把执行到一半的线程终止。</p><p>stop会释放对象锁，可能会造成数据不一致。</p>]]></content>
      
      
      <categories>
          
          <category> java 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解MySQL底层数据结构算法</title>
      <link href="/2024/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ol><li>索引是帮助MySQL高效获取数据的排好序的数据结构</li><li>索引的数据结构：二叉树，红黑树，Hash表，B-树</li></ol><h3 id="分析select语句"><a href="#分析select语句" class="headerlink" title="分析select语句"></a>分析select语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h4 id="没有加索引"><a href="#没有加索引" class="headerlink" title="没有加索引"></a>没有加索引</h4><p>没有加索引时，MySQL底层是通过一行一行的进行查找的，当找找到age&#x3D;18的字段后依然不能确定后面的数据时候还有age&#x3D;18的字段，所以依然需要继续查找，一次查找就是一次磁盘IO（<strong>Mysql 通过磁盘 IO 次数衡量查询效率</strong>的），如果一张表有10万条数据那么就需要进行10万次的查找，把数据从磁盘加载到内存的速度不快，如果数据量大的话，需要花费相当多的时间，才能扫描完整张表。</p><h4 id="加索引（二叉树）"><a href="#加索引（二叉树）" class="headerlink" title="加索引（二叉树）"></a>加索引（二叉树）</h4><p>加索引后，MySQL的查找就发生了变化，索引就是一种数据结构，如果索引是二叉树的话，就通过二叉树来查找。使用age索引后，就先去二叉树里去查找，每一个节点就相当于是键值对key存储的是age的值，value存储的就是文件地址指针（指向一列的数据）。要知道二叉树中一个节点的值大于它的左孩子小于它的右孩子，所以查找速度会很快。</p><h4 id="MySQL索引使用的数据结构"><a href="#MySQL索引使用的数据结构" class="headerlink" title="MySQL索引使用的数据结构"></a>MySQL索引使用的数据结构</h4><p>体会了一把索引查找数据结构，发现索引确实提高了我们的查找速度。而我们知道MySQL索引使用额数据结构是B+树，先不考虑为什么选用B+树，先来考虑为什么不选用二叉树，因为二叉树存在弊端，当数据是按一定顺序来存储的话，二叉树就会退化成链表，这样的话查找速度就没有得到提升。那有没有一种数据结构能够做到避免这种弊端呢?接下来我们看看平衡二叉树红黑树。</p><p>给出一段数据1,2,3,4,5,6,7,8,9。</p><p>用二叉树存储</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cca300c2b09b2b9a2f2efb0761104b08.png#pic_center" alt="在这里插入图片描述"></p><p>用红黑树来存储，如下</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dff171ece61403399d2eef6cf2e776b8.png#pic_center" alt="在这里插入图片描述"></p><p>从红黑树额构建中发现当红黑树自身不能满足红黑树的特性的时候，红黑树会自旋，以保持红黑树的特性。那么既然解决了退化成链表的问题为什么又没有选择它呢？</p><p>我们要知道<strong>AVL 树和红黑树基本都是存储在内存中才会使用的数据结构</strong>。&#x3D;&#x3D;在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘 IO 读写过于频繁，进而导致效率低下的情况&#x3D;&#x3D;。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘 IO 代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘 IO 频繁读写。根据<strong>磁盘查找存取的次数往往由树的高度所决定</strong>，所以，我们需要通过某种较好的树结构减少树的结构尽量减少树的高度来优化。</p><p>这时有人就会说B-树，很好B-树能够解决树的深度的问题</p><p>我们先来看看B-树的索引原理：B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；因此，B-Tree的查找过程是一个顺指针查找结点和在结点的关键字中进行查找的交叉进行的过程。</p><p>接下来看看B-树对数据的存储，依然使用上面的数据1,2,3,4,5,6,7,8,9，且设置Max.degree&#x3D;4</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c98586533d551318bf53fb805cf59bdd.png#pic_center" alt="在这里插入图片描述"></p><p>了解完B-树的索引原理，这时候我们就可以拍手叫绝了，B-树相对于红黑树一定程度上解决了树的高度问题了，那么mysql的索引就可以使用B-树了吧。这时候mysql就会给你当头一击，mysql实际使用的数据结构是B+树。</p><p>B+树存储1,2,3,4,5,6,7,8,9，且设置Max.degree&#x3D;4</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0932bb9028181676831650b465beb76.png#pic_center" alt="在这里插入图片描述"></p><p>通过以上的图有一定数据结构基础的朋友就会想起一些区别</p><p>这里就直接贴上总结：</p><p>B树的特征：</p><ul><li><strong>关键字集合分布在整颗树中</strong></li><li><strong>任何一个关键字出现且只出现在一个结点中</strong></li><li>搜索有可能在非叶子结点结束（<strong>data与在节点</strong>）</li><li>其搜索性能等价于在关键字全集内做一次二分查找</li><li>自动层次控制</li></ul><p>B+树的特征：</p><ul><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的</li><li><strong>不可能在非叶子结点命中（data域在叶子节点）</strong></li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），<strong>叶子结点相当于是存储（关键字）数据的数据层</strong></li><li>每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li><li>更适合文件索引系统</li></ul><p>B+树是B树的一个变体，区别在于，B+树：</p><ol><li><strong>叶子结点包含所有关键字以及指向相应记录的指针</strong></li><li><strong>叶子结点中的关键字有序，相邻节点用指针连接</strong></li><li>非叶子结点仅存储其子树的最大（或最小）关键字，可以看成是索引</li></ol><h4 id="B-树作为数据库索引的原因"><a href="#B-树作为数据库索引的原因" class="headerlink" title="B+ 树作为数据库索引的原因"></a><strong>B+ 树作为数据库索引的原因</strong></h4><ul><li>B+ 树<strong>非叶结点仅存储其子树的最大（或最小）关键字（不存放真正数据）</strong>，一个结点可以存储更多的关键字</li><li>每个结点能索引的<strong>范围更大更精确</strong></li><li>B+ 树单次磁盘IO的<strong>信息量大</strong>于 B 树，I&#x2F;O 的次数相对减少</li><li><strong>MySQL是一种关系型数据库，区间访问是常见的一种情况，B+树叶结点增加的链指针，加强了区间访问性；B 树则无法进行区间查找</strong></li></ul><h4 id="索引存储在文件系统中"><a href="#索引存储在文件系统中" class="headerlink" title="索引存储在文件系统中"></a><strong>索引存储在文件系统中</strong></h4><p>索引是占据物理空间的，在不同的存储引擎中，索引存在的文件也不同</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5511cbc5e57f914971bc925bdc121ada.png#pic_center" alt="在这里插入图片描述"></p><h4 id="MySQL叶结构示意图"><a href="#MySQL叶结构示意图" class="headerlink" title="MySQL叶结构示意图"></a>MySQL叶结构示意图</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/02bd101f4e88b36dad26c45c31dd334b.png#pic_center" alt="在这里插入图片描述"></p><h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><ul><li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，主文件按照对应字段排序存储，索引文件无重复排序存储。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e12ebf746e3c75f4af813f9f6f32e5c2.png#pic_center" alt="在这里插入图片描述"></p><ul><li>聚集：把索引的元素和数据存储在一个文件中（*.ibd）</li></ul></li><li><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，主文件并没有按照对应字段排序存储，索引文件有重复排序存储。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4c0995c2262bec4cf8c9a1eec7d9d780.png#pic_center" alt="在这里插入图片描述"></p><ul><li>非聚集：把索引的元素和数据存储在不同的文件中，*.MYI存储索引， *.MYD存储数据</li></ul></li></ul><h4 id="InnoDB索引的实现（聚集）"><a href="#InnoDB索引的实现（聚集）" class="headerlink" title="InnoDB索引的实现（聚集）"></a>InnoDB索引的实现（聚集）</h4><ul><li>表数据文件本身就是按B+Tree组织的一个索引结构文件</li><li>聚集索引叶子结点包含完整的数据记录</li><li>为什么InnoDB表必须有主键，并且推荐使用整形的自增主键？<ul><li>如果设置了主键，那么InnoDB会选择主键作为聚集索引、</li><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增)。</li><li>MySQL官方工程师就是这么设计的（更具主键来存储）</li><li>如果表使用&#x3D;&#x3D;自增主键&#x3D;&#x3D;那么每次插入新的记录，记录就会顺序添加到<strong>当前索引节点的后续</strong>位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页</li><li>如果使用&#x3D;&#x3D;非自增主键&#x3D;&#x3D;（如果身份证号或学号等）由于每次插入主键的值近似于随机，因此每次新纪录都要被插到<strong>现有索引页得中间某个位置</strong>，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li><li>uuid的使用与整形的对比：uuid比整形占用更多的存储空间；整形的比较效率更快（UUID是16字节128位长的数字，通常以36字节的字符串表示）</li></ul></li><li>为什么非主键索引结构叶子结点存储主键？（一致性和节约存储空间）<ul><li><strong>保持一致性：</strong><br>当数据库表进行DML操作时，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需进行更改。</li><li>** 节省存储空间：**<br>Innodb数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据。</li></ul></li></ul><p>参考：</p><ol><li><a href="https://blog.csdn.net/wangfeijiu/article/details/113409719">https://blog.csdn.net/wangfeijiu/article/details/113409719</a></li><li><a href="https://long97.blog.csdn.net/article/details/106084627">https://long97.blog.csdn.net/article/details/106084627</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记总结</title>
      <link href="/2024/11/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/11/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><p>在Java中的数据类型有四类八种</p><h3 id="整数型：byte-short-int-long"><a href="#整数型：byte-short-int-long" class="headerlink" title="整数型：byte short int long"></a>整数型：byte short int long</h3><p>byte ：1字节，8位，  1 byte &#x3D; 8 bits， byte 的默认值 0 </p><p>Short:  占用两个字节，也就是16位，1 short &#x3D; 2 byte &#x3D; 16 bits， 默认值 0；</p><p>Int: 占用四个字节，32位，1 int &#x3D; 32 bits，默认0；</p><p>long : 占用八字节，64位 ， 1 long &#x3D; 64 bits , 默认0L；</p><p>占用字节空间的大小： long &gt; int &gt; short &gt; byte</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型有两种数据类型：float 和 double</p><p>float：单精度浮点型，占用4位，1float &#x3D; 32bits , 默认0.01f;</p><p>Double:双精度浮点型，占用8位，1 double &#x3D; 64 bits ，默认值 0.0d；</p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p> char: char类型是一个单一的  16 的 <code>Unicode</code>·字符， 最小值是**&#x3D;&#x3D;<code>\u0000</code> ( 值为0 )&#x3D;&#x3D;**，最大值是&#x3D;&#x3D;<code>\uffff</code> ( 值为65535)&#x3D;&#x3D;，char类型可以存储任何字符，例如char a &#x3D; ‘A’.</p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>boolean ： boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><p>注意：上面的位数代表的是内存中的占用。</p><table><thead><tr><th align="left">类型</th><th align="left">位数</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">8</td><td align="left">-2<sup>7</sup> ~ 2<sup>7</sup> - 1</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16</td><td align="left">\u0000 ~ \uffff</td><td align="left">‘u0000’</td></tr><tr><td align="left">short</td><td align="left">16</td><td align="left">-2<sup>15</sup> ~ 2<sup>15</sup> - 1</td><td align="left">0</td></tr><tr><td align="left">int</td><td align="left">32</td><td align="left">-2<sup>31</sup> ~ 2<sup>31</sup> - 1</td><td align="left">0</td></tr><tr><td align="left">float</td><td align="left">32</td><td align="left">-2<sup>31</sup> ~ 2<sup>31</sup> - 1</td><td align="left">0.0f</td></tr><tr><td align="left">double</td><td align="left">64</td><td align="left">-2<sup>63</sup> ~ 2<sup>63</sup> - 1</td><td align="left">0.0d</td></tr><tr><td align="left">long</td><td align="left">64</td><td align="left">-2<sup>63</sup> ~ 2<sup>63</sup> - 1</td><td align="left">0L</td></tr><tr><td align="left">boolean</td><td align="left">~</td><td align="left">~</td><td align="left">false</td></tr></tbody></table><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 20; // 装箱    自动装箱就是jdk自己自动帮我们完成了Integer.valueOf()方法的调用</span><br><span class="line">int y = x;      // 拆箱 自动拆箱就是jdk自动帮我们调用了IntValue()方法</span><br></pre></td></tr></table></figure><p>Integer的值在-128到127时，Integer对象是在IntegerCache.cache产生，会复用已有对象，也就是说，这个区间的Integer可以直接用等号进行判断。<br>Integer的值在-128到127之外时，Integer对象在堆上产生，不会复用已有对象，用等号会返回false</p><p>扩展：</p><p>缓存，以支持 JLS 要求的 -128 和 127（含）之间的值的自动装箱的对象标识语义。缓存在首次使用时初始化。缓存的大小可以通过 -XX：AutoBoxCacheMax&#x3D; 选项进行控制<size>。在虚拟机初始化期间，可以在 sun.misc.VM 类的专用系统属性中设置并保存 java.lang.Integer.IntegerCache.high 属性。</p><p><a href="https://blog.csdn.net/qq_43663493/article/details/118943794?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171666010516800197012449%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=171666010516800197012449&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-118943794-null-null.nonecase&utm_term=%E8%A3%85%E7%AE%B1&spm=1018.2226.3001.4450">自动装箱与自动拆箱</a></p><h2 id="String-、-StringBuffer、StringBuilder-的区别"><a href="#String-、-StringBuffer、StringBuilder-的区别" class="headerlink" title="String 、 StringBuffer、StringBuilder 的区别"></a>String 、 StringBuffer、StringBuilder 的区别</h2><p>String 被声明为 final，因此它不可被继承。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。</p><p>在 Java 8 中，String 内部使用 <code>char</code> 数组存储数据。</p><p>Java 9 之后，String 类的实现改用 <code>byte</code> 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，<code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串 char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    AbstractStringBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String, StringBuffer and StringBuilder</strong></p><ul><li>String 不可变是线程安全的</li><li>StringBuffer 和 StringBuilder 可变， StringBuilder 不是线程安全的， StringBuffer 是线程安全的，内部使用 <code>synchronized</code> 进行同步</li></ul><h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”) ?"></a>new String(“abc”) ?</h3><p>使用这种方式一共会创建两个字符串对象（前提是 <code>String Pool</code> 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，编译时期会在 <code>String Pool</code> 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>使用 new 的方式会在 <code>堆</code> 中创建一个字符串对象</li></ul><h3 id="String-的几种拼接方式区"><a href="#String-的几种拼接方式区" class="headerlink" title="String 的几种拼接方式区"></a>String 的几种拼接方式区</h3><h4 id="使用-拼接字符串"><a href="#使用-拼接字符串" class="headerlink" title="使用 + 拼接字符串"></a><strong>使用 <code>+</code> 拼接字符串</strong></h4><p><strong>其实只是Java提供的一个语法糖</strong></p><p>原理：字符串常量在拼接过程中，将 String 转成了 StringBuilder 后，使用其 append 方法进行处理的</p><h4 id="使用concat"><a href="#使用concat" class="headerlink" title="使用concat:"></a>使用<strong>concat</strong>:</h4><p>先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的 String 对象并返回.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>&#x3D;&#x3D;算术运算符优先级较高，关系和逻辑运算符优先级较低&#x3D;&#x3D;。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性。</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th><th align="left">结核性</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">() 、[] 、{}</td><td align="left">从左往右</td></tr><tr><td align="left">2</td><td align="left">!、 +、 -、 ~、 ++、 –</td><td align="left">从右往左</td></tr><tr><td align="left">3</td><td align="left">*、 &#x2F;、 %</td><td align="left">从左往右</td></tr><tr><td align="left">4</td><td align="left">+、 -</td><td align="left">从左往右</td></tr><tr><td align="left">5</td><td align="left">&lt;&lt;、 &gt;&gt;、 &gt;&gt;&gt;</td><td align="left">从左往右</td></tr><tr><td align="left">6</td><td align="left">&lt;、 &lt;&#x3D;、 &gt;、 &gt;&#x3D;、 instanceof</td><td align="left">从左往右</td></tr><tr><td align="left">7</td><td align="left">&#x3D;&#x3D;、 !&#x3D;</td><td align="left">从左往右</td></tr><tr><td align="left">8</td><td align="left">&amp;</td><td align="left">从左往右</td></tr><tr><td align="left">9</td><td align="left">^</td><td align="left">从左往右</td></tr><tr><td align="left">10</td><td align="left">|</td><td align="left">从左往右</td></tr><tr><td align="left">11</td><td align="left">&amp;&amp;</td><td align="left">从左往右</td></tr><tr><td align="left">12</td><td align="left">||</td><td align="left">从左往右</td></tr><tr><td align="left">13</td><td align="left">?:</td><td align="left">从右往左</td></tr><tr><td align="left">14</td><td align="left">&#x3D;、 +&#x3D;、 -&#x3D;、 *&#x3D;、 &#x2F;&#x3D;、 &amp;&#x3D;、 |&#x3D;、 ^&#x3D;、 ~&#x3D;、 &lt;&lt;&#x3D;、 &gt;&gt;&#x3D;、  &gt;&gt;&gt;&#x3D;</td><td align="left">从右往左</td></tr></tbody></table><h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重载： 发生在同一个类中，&#x3D;&#x3D;方法名必须相同，参数类型不同、个数不同、顺序不同&#x3D;&#x3D;</p><p>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类.</p><p>哪些方法不可以被重写：final 方法、<strong>静态方法</strong>、private 不可见方法</p><p>对象的多态性：</p><ul><li>子类如果重写了父类的方法，通过子类对象调用的不一定是子类重写过的代码</li><li>非静态方法默认的调用对象是 this</li><li>this 对象在构造器或者说 <code>&lt;init&gt;</code> 方法中就是在还能够在创建的对象</li></ul><h3 id="Object-类通用方法"><a href="#Object-类通用方法" class="headerlink" title="Object 类通用方法"></a>Object 类通用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//返回当前运行时对象的Class对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">//返回对象的哈希码，主要使用在哈希表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> <span class="comment">//用于比较 2 个对象的内存地址是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//创建并返回当前对象的一份拷贝。对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span><span class="comment">//唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span><span class="comment">//唤醒在此对象监视器上等待的所有线程，而不是一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，表示额外时间(毫秒)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><h2 id="与-equals"><a href="#与-equals" class="headerlink" title="&#x3D;&#x3D; 与 equals"></a>&#x3D;&#x3D; 与 equals</h2><p>&#x3D;&#x3D; : 基本数据类型比较的是值，引用数据类型比较的是内存地址</p><p>equals : 判断两个对象是否相等</p><p><strong>注意：</strong></p><ul><li>String 重写 equals 方法，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值</li><li>在自定义类重写 equals 方法必须重写 hashCode 方法</li><li>hashCode() 相等是两个对象相等的必要不充分条件</li><li>equals 相等是两个对象相等的必要条件</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li>浅拷贝：拷贝对象与原对象的引用时同一个对象</li><li>深拷贝：拷贝对象与原对象的引用为不同对象</li></ul><h3 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h3><p><strong>基本数据类型</strong>：传递数据值</p><p><strong>引用类型</strong>：传递地址值</p><p><strong>特殊类型</strong>：String、包装类等对象的不可变性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    change(i, str, num, arr, t);</span><br><span class="line"></span><br><span class="line">    System.out.println(i); <span class="comment">// 1</span></span><br><span class="line">    System.out.println(str); <span class="comment">// hello</span></span><br><span class="line">    System.out.println(num); <span class="comment">// 200</span></span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">// [2,3,3]</span></span><br><span class="line">    System.out.println(t.a); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> j, String s, Integer n, <span class="type">int</span>[] a, Test t)</span>&#123;</span><br><span class="line">    j += <span class="number">1</span>;</span><br><span class="line">    s += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">    t.a += <span class="number">1</span>; <span class="comment">// 修改的是对象的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li>类 ： 类不能被继承，所有成员方法都会被隐式地指定为final方法</li><li>变量 : 基本数据类型变量初始化之后便不能更改；引用类型的变量初始化之后便不能再让其指向另一个对象</li><li>方法 ： 方法锁定，禁止被继承类重写</li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>初始化顺序：<strong>静态变量和静态语句块优先于实例变量和普通语句块</strong>，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><ul><li>一个类要创建实例需要先加载并初始化该类<ul><li>main 方法所在的类需要先加载和初始化</li></ul></li><li>一个子类要初始化需要先初始化父类</li><li>一个类初始化就是执行 <code>&lt;clinit&gt;</code> 方法<ul><li><clinit>&#96; 方法由静态类变量显示赋值代码和静态代码块组成</li><li>类变量显示赋值代码和静态代码块从上到下顺序执行</li><li><code>&lt;clinit&gt;</code> 方法只执行一次</li></ul></li></ul><h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><ul><li>实例初始化就是执行<code>&lt;init&gt;</code>方法<ul><li><code>&lt;init&gt;</code> 方法可能重载有多个有几个构造器就有几个<code>&lt;init&gt;</code>方法</li><li><code>&lt;init&gt;</code> 方法由非静态实例变量显示赋值代码和非静态代码块、对应狗在其代码组成</li><li>非静态实例变量显示赋值代码和非静态代码块从上到下执行，构造器代码最后执行</li><li>每次创建实例对象调用对象的构造器，执行对应的<code>&lt;init&gt;</code> 方法</li></ul></li></ul><h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> in.nextLine();</span><br><span class="line">in.close();</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine();</span><br></pre></td></tr></table></figure><h1 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h1><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><ul><li>Set<ul><li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说 使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul></li><li>List<ul><li>ArrayList：基于动态数组实现，支持随机访问。</li><li>Vector：和 ArrayList 类似，线程安全。</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul></li><li>Queue<ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li></ul></li></ul><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h2 id="面试问题："><a href="#面试问题：" class="headerlink" title="面试问题："></a>面试问题：</h2><p>1、在一个静态方法内调用一个非静态成员为什么是非法的?</p><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><p>2、在 Java 中定义一个不做事且没有参数的构造方法的作用？</p><p>Java 程序在执行子类的构造方法之前，&#x3D;&#x3D;如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中无参构造方法&#x3D;&#x3D;。如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误。</p><p>3、抽象类与接口的区别</p><ul><li>接口的方法默认是 <code>public</code> , 所有方法在接口中不能有实现（JDK 8 接口允许有默认实现，静态方法）；抽象类可以有非抽象方法</li><li>接口中实例变量默认为 final 类型；抽象类不一定</li><li>一个类可以实现多个接口，但只能实现一个抽象类</li><li>一个类实现接口需要实现接口中的所有方法</li><li>&#x3D;&#x3D;接口不能用 new 实例化，但可以声明&#x3D;&#x3D;</li></ul><p>4、为什么 Java 中只有值传递？</p><ul><li>按值调用(call by value)表示方法接收的是调用者提供的值。</li><li>按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。</li></ul><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p><strong>Java 程序设计语言总是采用按值调用。方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</strong></p><p>5、Java 序列化中如果有些字段不想进行序列化，怎么办？</p><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p><h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><h1 id="Java“锁”"><a href="#Java“锁”" class="headerlink" title="Java“锁”"></a>Java“锁”</h1><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><p>悲观锁：&#x3D;&#x3D;认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。&#x3D;&#x3D;synchronized关键字和Lock的实现类都是悲观锁。适合写操作多的场景，先加锁可以保证写操作时数据正确。显式的锁定之后再操作同步资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=============悲观锁的调用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//加锁后的业务逻辑......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">lock.lock();...</span><br></pre></td></tr></table></figure><p>乐观锁:&#x3D;&#x3D;乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入&#x3D;&#x3D;。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再抢。</p><p>乐观锁一般有两种实现方式：1、采用版本号机制。2、CAS（Compare-and-Swap，即比较并替换）算法实现。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>何为公平锁&#x2F;非公平锁?t</p><p>⽣活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//默认false用的是非公平锁，分配的平均一点，=--》公平一点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Object objectLock = new Object();</span></span><br><span class="line"><span class="comment">    public void sale()&#123;</span></span><br><span class="line"><span class="comment">        synchronized (objectLock) &#123;</span></span><br><span class="line"><span class="comment">            if(number &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(Thread.currentThread().getName()+&quot;\t 卖出第: &quot;+(number--)+&quot;\t 还剩下: &quot;+number);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;d&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;e&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</strong></p><p>1、恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</p><p>2、使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</p><p><strong>使⽤公平锁会有什么问题？</strong></p><p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”。</p><p><strong>什么时候用公平？什么时候用非公平？</strong></p><p>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；否则那就用公平锁，大家公平使用。</p><h2 id="可重入锁-又名递归锁"><a href="#可重入锁-又名递归锁" class="headerlink" title="可重入锁(又名递归锁)"></a>可重入锁(又名递归锁)</h2><p>​可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p><p>​如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。所以Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><h3 id="可重入锁种类"><a href="#可重入锁种类" class="headerlink" title="可重入锁种类"></a>可重入锁种类</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁。</p><p>隐式锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。<br>简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的。与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</p><h5 id="同步快"><a href="#同步快" class="headerlink" title="同步快"></a>同步快</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock) &#123;<span class="comment">// lock</span></span><br><span class="line">            System.out.println(<span class="string">&quot;-----外层&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----中层&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----内层&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//unlock</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用并且不发生死锁，这样的锁就叫做可重入锁。</span></span><br><span class="line"><span class="comment"> * 简单的来说就是：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Synchronized的重入的实现机理"><a href="#Synchronized的重入的实现机理" class="headerlink" title="Synchronized的重入的实现机理"></a>Synchronized的重入的实现机理</h4><p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p><p>当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p><p>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p><p>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p><p>为什么任何一个对象都可以成为一个锁？</p><p>在Java中，任何一个对象都可以成为一个锁是因为Java的内置同步机制是基于每个对象的监视器（monitor）实现的。监视器是一种同步工具，可以用来协调多个线程对同一个对象的访问。</p><h4 id="显式锁（即Lock）"><a href="#显式锁（即Lock）" class="headerlink" title="显式锁（即Lock）"></a>显式锁（即Lock）</h4><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----外层&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------22222&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="死锁及排查"><a href="#死锁及排查" class="headerlink" title="死锁及排查"></a>死锁及排查</h2><p>​死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p>产生死锁主要原因:</p><ol><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ol><p>死锁案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有A锁，期待获得B锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得B锁成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有B锁，期待获得A锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得A锁成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何排查死锁</p><p>纯命令: 1、jps -l ；2、jstack 进程编号；</p><p>图形化：jconsole</p><h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h2><p>1、进程：是程序的⼀次执⾏，是&#x3D;&#x3D;系统进⾏资源分配和调度的独⽴单位&#x3D;&#x3D;，每⼀个进程都有它⾃⼰的内存空间和系统资源。</p><p>2、线程：在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程，⼀个进程会有1个或多个线程。</p><p>3、管程：即Monitor(监视器)，也就是我们平时所说的锁。</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    </span><br><span class="line">  <span class="keyword">synchronized</span> (o)    &#123;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p><p>4、用户线程和守护线程</p><p>Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程。</p><p>守护线程：是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程。</p><p>用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.itdachang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 开始运行，&quot;</span>+(Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span>:<span class="string">&quot;用户线程&quot;</span>));        </span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);    </span><br><span class="line">    <span class="comment">//线程的daemon属性为true表示是守护线程，false表示是用户线程    </span></span><br><span class="line">    t1.setDaemon(<span class="literal">true</span>);    </span><br><span class="line">    t1.start();    </span><br><span class="line">    <span class="comment">//3秒钟后主线程再运行    </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">3</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">      e.printStackTrace(); </span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(<span class="string">&quot;----------main线程运行完毕&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出。如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以&#x3D;&#x3D;当系统只剩下守护进程的时候，java虚拟机会自动退出&#x3D;&#x3D;。设置守护线程，需要在start()方法之前进行。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>方式一：<strong>使用 Thread类或继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>方式二：<strong>实现 Runnable 接口配合Thread</strong></p><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start(); </span><br></pre></td></tr></table></figure><p><strong>方式3：使用有返回值的 Callable</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>()); </span><br></pre></td></tr></table></figure><p>方式4:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">  () -&gt; System.out.println(Thread.currentThread().getName())</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><blockquote><p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法.</p></blockquote><h3 id="线程启动和停止"><a href="#线程启动和停止" class="headerlink" title="线程启动和停止"></a>线程启动和停止</h3><p>线程启动：调用start方法</p><p>线程停止：调用stop方法</p><p>注意：线程自带的stop方法，一方面已经过时，另一方面，&#x3D;&#x3D;不会对停止的线程做状态保存，使得线程中涉及的对象处于未知状态&#x3D;&#x3D;，如果这些状态，其他线程也会使用，将会使得其他线程出现无法预料的异常，所以，停止程序的功能，需要自己实现。</p><h3 id="线程暂停和中断"><a href="#线程暂停和中断" class="headerlink" title="线程暂停和中断"></a>线程暂停和中断</h3><p>暂停:Java中线程的暂停是调用 java.lang.Thread 类的 sleep 方法。该方法会使当前正在执行的线程暂停,指定的一段时间，如果线程持有锁，&#x3D;&#x3D;sleep 方法结束前并不会释放该锁&#x3D;&#x3D;。</p><p>中断: interrupt 方法，该方法直接对线程调用。&#x3D;&#x3D;当被interrupt的线程正在sleep或wait时，会抛出 InterruptedException 异常&#x3D;&#x3D;。interrupt 方法只是改变目标线程的中断状态（interrupt status），而那些会抛出InterruptedException 异常的方法，如wait、sleep、join等，都是在方法内部不断地检查中断状态的值。</p><ul><li><p>interrupt方法</p><p>Thread实例方法：必须由其它线程获取被调用线程的实例后，进行调用。实际上，只是改变了被调用线程的内部中断状态；</p></li><li><p>Thread.interrupted方法</p><p>Thread类方法：必须在当前执行线程内调用，该方法返回当前线程的内部中断状态，然后清除中断状态（置为false） ；</p></li><li><p>isInterrupted方法</p><p>Thread实例方法：用来检查指定线程的中断状态。当线程为中断状态时，会返回true；否则返回false。</p></li></ul><p>interrupt() ：</p><ul><li>interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；</li><li>如果线程处于sleep, wait, join 等状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；</li><li>如果线程处于I&#x2F;O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异常；</li><li>如果线程在Selector上被阻塞，select方法将立即返回；</li><li>如果非以上情况，将直接标记 interrupt 状态；</li></ul><p>注意：interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，如处于锁阻塞的线程，不会受 interrupt 中断；</p><p>阻塞情况下中断，抛出异常后线程恢复非中断状态，即 interrupted &#x3D; false</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java线程可能的状态：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="image-20240527003435340"></p><p>线程的状态变迁</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="image-20240526212126155"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li></ul><h3 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h3><p>提高cpu的利用率：在等待磁盘IO，网络IO或者等待用户输入时，CPU可以同时去处理其他任务。</p><p>更高效的响应：多线程使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态，不会造成无法响应的现象。</p><p>公平使用CPU资源：当前没有进行处理的任务，可以将处理器时间让给其它任务;占用大量处理时间的任务，也可以定期将处理器时间让给其它任务;通过对CPU时间的划分，使得CPU时间片可以在多个线程之间切换，避免需要长时间处理的线程独占CPU，导致其它线程长时间等待。</p><h3 id="多线程的代价"><a href="#多线程的代价" class="headerlink" title="多线程的代价"></a>多线程的代价</h3><p>更复杂的设计</p><p>​共享数据的读取，数据的安全性，线程之间的交互，线程的同步等；</p><p>上下文环境切换</p><p>​线程切换，cpu需要保存本地数据、程序指针等内容；</p><p>更多的资源消耗</p><p>​每个线程都需要内存维护自己的本地栈信息，操作系统也需要资源对线程进行管理维护；</p><h2 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>​&#x3D;&#x3D;临界资源是一次仅允许一个进程使用的共享资源。&#x3D;&#x3D;<strong>各进程采取互斥的方式，实现共享的资源称作临界资源。</strong>属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="comment">// 临界资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 临界区  （在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制。）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> value)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.count = <span class="built_in">this</span>.count + value;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>何谓竞态条件</strong></p><p>​当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p><p>​导致竞态条件发生的代码区称作临界区。</p><p>​在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制。</p><p><strong>何谓线程安全</strong></p><p>​允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。</p><h3 id="对象的安全"><a href="#对象的安全" class="headerlink" title="对象的安全"></a>对象的安全</h3><h4 id="局部基本类型变量"><a href="#局部基本类型变量" class="headerlink" title="局部基本类型变量"></a>局部基本类型变量</h4><p>&#x3D;&#x3D;局部变量存储在线程自己的栈中。&#x3D;&#x3D;也就是说，局部变量永远也不会被多个线程共享（只是更新当前线程栈的值，不会影响其他线程，也就是不共享数据）。所以，基础类型的局部变量是线程安全的。</p><h4 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h4><p>对象的局部引用和基础类型的局部变量不太一样，尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。</p><p>如果在某个方法中创建的对象不会逃逸出（即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。</p><p>实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 该对象不会逃逸出</span></span><br><span class="line"><span class="type">LocalObject</span> <span class="variable">localObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalObject</span>();</span><br><span class="line">localObject.callMethod();</span><br><span class="line">method2(localObject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(LocalObject localObject)</span>&#123;</span><br><span class="line">localObject.setValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象成员-成员变量"><a href="#对象成员-成员变量" class="headerlink" title="对象成员(成员变量)"></a>对象成员(成员变量)</h3><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NotThreadSafe</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotThreadSafe</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(sharedInstance)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(sharedInstance)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">NotThreadSafe</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(NotThreadSafe instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance.add(<span class="string">&quot; &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.instance.builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotThreadSafe</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder.append(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableValue</span>&#123;</span><br><span class="line">  <span class="comment">// 创建的该属性不可变（没有set方法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ImmutableValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImmutableValue类的成员变量 value 是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建， value 变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/JMM.png" alt="image-20240527015028358"></p><p>线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol><h2 id="CAS乐观锁"><a href="#CAS乐观锁" class="headerlink" title="CAS乐观锁"></a>CAS乐观锁</h2><p>乐观锁：不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。其实现方式有一种比较典型的就是Compare and Swap( CAS )。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><p>1.在内存地址V当中，存储着值为10的变量。</p><p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270159880.png" alt="image-20240527015919145"></p><p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270159406.png" alt="image-20240527015941075"></p><p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270201086.png" alt="image-20240527020130548"></p><p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A&#x3D;11，B&#x3D;12。这个重新尝试的过程被称为自旋。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270203433.png" alt="image-20240527020313272"></p><p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270205946.png" alt="image-20240527020529111"></p><p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270206835.png" alt="image-20240527020630202"></p><p>Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>CAS的缺点：</p><p>1.CPU开销较大</p><p>​在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p><p>2.不能保证代码块的原子性</p><p>​CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p><h2 id="Synchronized块"><a href="#Synchronized块" class="headerlink" title="Synchronized块"></a>Synchronized块</h2><p>Java中的同步块用&#x3D;&#x3D;synchronized标记&#x3D;&#x3D;。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p><h3 id="同步块的分类："><a href="#同步块的分类：" class="headerlink" title="同步块的分类："></a>同步块的分类：</h3><ol><li><p>实例方法的同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法声明中同步（synchronized ）关键字。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java实例方法同步是&#x3D;&#x3D;同步在拥有该方法的对象上&#x3D;&#x3D;。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。</p></li><li><p>静态方法的同步</p><p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法的同步是指&#x3D;&#x3D;同步在该方法所在的类对象上&#x3D;&#x3D;。因为在Java虚拟机中<strong>一个类只能对应一个类对象</strong>，所以同时只允许一个线程执行同一个类中的静态同步方法。</p><p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p></li><li><p>实例方法中的同步块</p><p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.count += value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为&#x3D;&#x3D;add方法的实例本身&#x3D;&#x3D;。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p><p>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。</p><p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">log1</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line">log.writeln(msg1);</span><br><span class="line">log.writeln(msg2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">log.writeln(msg1);</span><br><span class="line">log.writeln(msg2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。</p><p>&#x3D;&#x3D;如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。&#x3D;&#x3D;在 Java 中，<code>synchronized(this)</code> 确实锁住了调用该方法的对象。锁定对象时，其他任何试图进入被同一对象锁定的 <code>synchronized</code> 方法或 <code>synchronized</code> 块的线程都会被阻塞，直到锁被释放。而试图进入该对象的非 <code>synchronized</code> 方法或非 <code>synchronized</code> 代码块的线程不会被阻塞，它们可以正常运行。</p></li><li><p>静态方法中的同步块</p></li></ol><p>同步在该方法所属的类对象上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">log1</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line">log.writeln(msg1);</span><br><span class="line">log.writeln(msg2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">(String msg1, String msg2)</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(MyClass.class)&#123;</span><br><span class="line">log.writeln(msg1);</span><br><span class="line">log.writeln(msg2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法不允许同时被线程访问。</p><p>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p><h3 id="Synchronized锁的存储"><a href="#Synchronized锁的存储" class="headerlink" title="Synchronized锁的存储"></a>Synchronized锁的存储</h3><p>​synchronized用的&#x3D;&#x3D;锁存储在Java对象头&#x3D;&#x3D;，如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头，32位虚拟机，1字宽等于4字节，即32位。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><strong>对象的内存布局</strong></h4><p>Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><ul><li><p>对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。</p></li><li><p>实例数据：存放类的属性数据信息，包括父类的属性信息；</p></li><li><p>对齐填充：由于虚拟机要求 <strong>对象起始地址必须是8字节的整数倍</strong>。填充数据不是必须存在的，仅仅是为了字节对齐。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282137739.png" alt="img"></p></li></ul><h5 id="对象头详解"><a href="#对象头详解" class="headerlink" title="对象头详解"></a><strong>对象头详解</strong></h5><p>HotSpot虚拟机的对象头包括：</p><ul><li>Mark Word</li></ul><p>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（4位（与分代年龄有关））、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。</p><ul><li>Klass Pointer</li></ul><p>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 32位4字节，64位开启指针压缩或最大堆内存&lt;32g时4字节，否则8字节。jdk1.8默认开启指针压缩后为4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。</p><ul><li>数组长度（只有数组对象有）</li></ul><p>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度。 4字节</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270252460.png" alt="image-20240527025211529"></p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282136832.png" alt="image.png"></p><h5 id="Mark-Word的结构"><a href="#Mark-Word的结构" class="headerlink" title="Mark Word的结构"></a><strong>Mark Word的结构</strong></h5><p><strong>32位JVM下的对象结构描述</strong></p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282147663.png" alt="image.png"></p><p><strong>64位JVM下的对象结构描述</strong></p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282147130.png" alt="image.png"></p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>​程序不会有锁的竞争</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h5 id="偏向锁的获取流程："><a href="#偏向锁的获取流程：" class="headerlink" title="偏向锁的获取流程："></a>偏向锁的获取流程：</h5><p> （1）查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态。</p><p> （2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，若相同，表示线程已经获得了锁，如果不同，则进入（3）</p><p> （3）测试Mark Word的偏向锁的标识是否设置为1，如果没有设置，则使用&#x3D;&#x3D;CAS操作竞争锁&#x3D;&#x3D;，如果设置了，则尝试使用CAS尝试将Mark Word中线程ID设置为当前线程ID，如果尝试失败，则执行（4）</p><p> （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。当到达&#x3D;&#x3D;全局安全点（在这个时间点，没有正在执行的代码）&#x3D;&#x3D;时之前获得偏向锁的线程被挂起，&#x3D;&#x3D;偏向锁升级为轻量级锁&#x3D;&#x3D;，然后被阻塞在安全点的线程继续往下执行同步代码。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282207782.png" alt="image-20240528220750790"></p><h5 id="偏向锁JVM命令"><a href="#偏向锁JVM命令" class="headerlink" title="偏向锁JVM命令"></a>偏向锁JVM命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial |grep BiasedLock*</span><br><span class="line">-XX:+UseBiasedLocking：启用偏向锁定，这是 JVM 的默认设置。</span><br><span class="line">-XX:-UseBiasedLocking：禁用偏向锁定，所有锁将直接使用轻量级或重量级锁。</span><br><span class="line"></span><br><span class="line">例如：java -XX:-UseBiasedLocking -jar YourApplication.jar</span><br></pre></td></tr></table></figure><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282213888.png" alt="image-20240528221322470"></p><h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁</p><p>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282226235.png" alt="po_diagram (1)"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>​轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。</p><p>轻量级锁的加锁过程：</p><p>（1）<strong>当线程执行代码进入同步块时，若Mark Word为无锁状态，虚拟机先在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储当前对象的Mark Word的拷贝</strong>，官方称之为“Dispalced Mark Word”，此时状态如下图：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270255844.png" alt="image-20240527025457987"></p><p>（2）复制对象头中的Mark Word到锁记录中。</p><p>（3）复制成功后，虚拟机将用CAS操作将对象的Mark Word更新为执行Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行4，否则执行5。</p><p>（4）如果更新成功，则这个线程拥有了这个锁，并将锁标志设为00，表示处于轻量级锁状态，此时状态图：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405270255717.png" alt="image-20240527025543187"></p><p>（5）如果更新失败，则说明有其他线程竞争锁，当前线程便通过自旋来获取锁。轻量级锁就会膨胀为重量级锁，Mark Word中存储重量级锁（互斥锁）的指针，后面等待锁的线程也要进入阻塞状态。</p><h5 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h5><p>java6之前：默认启用，默认情况下自旋的次数是 10 次（-XX:PreBlockSpin&#x3D;10来修改）或者自旋线程数超过cpu核数一半。</p><p>Java6之后：自适应意味着自旋的次数不是固定不变的，而是根据：1.同一个锁上一次自旋的时间。2.拥有锁线程的状态来决定。</p><h5 id="轻量锁与偏向锁的区别和不同"><a href="#轻量锁与偏向锁的区别和不同" class="headerlink" title="轻量锁与偏向锁的区别和不同"></a>轻量锁与偏向锁的区别和不同</h5><ul><li>争夺轻量级锁失败时，自旋尝试抢占锁</li><li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li></ul><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>即当有其他线程占用锁时，当前线程会进入阻塞状态。（有大量的线程参与锁的竞争，冲突性很高）</p><h4 id="总结：锁对象状态转换"><a href="#总结：锁对象状态转换" class="headerlink" title="总结：锁对象状态转换"></a><strong>总结：锁对象状态转换</strong></h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282244810.png" alt="image-20240528224415233"></p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282224953.png" alt="po_diagram"></p><h2 id="关键字Volatile"><a href="#关键字Volatile" class="headerlink" title="关键字Volatile"></a>关键字Volatile</h2><h3 id="被volatile修改的变量有2大特点"><a href="#被volatile修改的变量有2大特点" class="headerlink" title="被volatile修改的变量有2大特点"></a>被volatile修改的变量有2大特点</h3><p>特点:  可见性 , 有序性</p><ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li><del>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性</del></li><li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性。</li></ul><h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值&#x3D;&#x3D;立即刷新回主内存中&#x3D;&#x3D;。</p><p>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，&#x3D;&#x3D;直接从主内存中读取共享变量&#x3D;&#x3D;</p><p><strong>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</strong></p><h3 id="内存屏障-面试重点必须拿下"><a href="#内存屏障-面试重点必须拿下" class="headerlink" title="内存屏障(面试重点必须拿下)"></a>内存屏障(面试重点必须拿下)</h3><blockquote><p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p><p>内存屏障之前的所有写操作都要回写到主内存，内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。<br>一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。</p></blockquote><h4 id="保证可见性和有序性"><a href="#保证可见性和有序性" class="headerlink" title="保证可见性和有序性"></a>保证可见性和有序性</h4><ol><li><strong>可见性</strong>：当一个线程修改了 <code>volatile</code> 变量的值，新值对于其他所有线程立即可见。</li><li><strong>禁止指令重排序</strong>：对 <code>volatile</code> 变量的读写操作不会被指令重排序，因此 <code>volatile</code> 变量的操作在内存中是有序的。</li></ol><p><strong>volatile重排序规则</strong>:</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202406011435088.png" alt="image-20240601143456443"></p><h4 id="volatile-不能保证原子性的原因"><a href="#volatile-不能保证原子性的原因" class="headerlink" title="volatile 不能保证原子性的原因"></a><code>volatile</code> 不能保证原子性的原因</h4><p>尽管 <code>volatile</code> 能确保变量的可见性和有序性，但它不能保证对变量的复合操作（例如读取-修改-写入）是原子的。例如，考虑以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 在多个线程中执行</span></span><br><span class="line">count++;</span><br></pre></td></tr></table></figure><p>在这里，<code>count++</code> 操作实际上分为三步：</p><ol><li>读取 <code>count</code> 的当前值。</li><li>将值加 1。</li><li>将新值写回 <code>count</code>。</li></ol><p>即使 <code>count</code> 是 <code>volatile</code> 的，其他线程可能会在步骤 1 和步骤 3 之间修改 <code>count</code> 的值，从而导致竞争条件和数据不一致的问题。因此，<code>count++</code> 不是一个原子操作。</p><h4 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282343216.png" alt="po_diagram"></p><p>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。<br>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。<br>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</p><h4 id="JMM-就将内存屏障插⼊策略分为-4-种"><a href="#JMM-就将内存屏障插⼊策略分为-4-种" class="headerlink" title="JMM 就将内存屏障插⼊策略分为 4 种"></a>JMM 就将内存屏障插⼊策略分为 4 种</h4><ol><li><p>在每个 volatile <strong>写</strong>操作的前⾯插⼊⼀个 StoreStore 屏障</p></li><li><p>在每个 volatile <strong>写</strong>操作的后⾯插⼊⼀个 StoreLoad 屏障</p></li><li><p>在每个 volatile <strong>读</strong>操作的后⾯插⼊⼀个 LoadLoad 屏障</p></li><li><p>在每个 volatile <strong>读</strong>操作的后⾯插⼊⼀个 LoadStore 屏障</p></li></ol><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282345615.png" alt="po_diagram (1)"></p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202406011436972.png" alt="image-20240601143620894"></p><h3 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h3><h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><p>说明：保证不同线程对这个变量进行操作时的可见性，即变量一旦改变所有线程立即可见。</p><h4 id="volatile变量的读写过程"><a href="#volatile变量的读写过程" class="headerlink" title="volatile变量的读写过程"></a>volatile变量的读写过程</h4><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282349584.png" alt="po_diagram (2)"></p><ol><li>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</li><li>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</li><li>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li><li>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</li><li>store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存</li><li>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</li><li>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁 ，所以，JVM提供了另外两个原子指令：</li><li>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</li><li>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</li></ol><h4 id="没有原子性"><a href="#没有原子性" class="headerlink" title="没有原子性"></a><span style="color: red;">没有原子性</span></h4><blockquote><p>volatile变量的复合操作(如i++)不具有原子性</p></blockquote><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405282352674.png" alt="po_diagram"></p><p>⚠️：数据加载、数据计算、数据赋值不是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span> &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileNoAtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myNumber.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + myNumber.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从i++的字节码角度说明：</p><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。<br>public void add(){<br>        i++; &#x2F;&#x2F;不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成<br> }<br>如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于add方法必须使用synchronized修饰，以便保证线程安全.</p><p>不保证原子性：多线程环境下，”数据计算”和”数据赋值”操作可能多次出现，即操作非原子。若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致 ；对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。<br>由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步</p><p>读取赋值一个普通变量的情况：</p><p>当线程1对主内存对象发起read操作到write操作第一套流程的时间里，线程2随时都有可能对这个主内存对象发起第二套操作。</p><p>既然一修改就是可见，为什么还不能保证原子性？</p><p>volatile主要是对其中部分指令做了处理</p><p>要use(使用)一个变量的时候必需load(载入），要载入的时候必需从主内存read(读取）这样就解决了读的可见性。 </p><p>写操作是把assign和store做了关联(在assign(赋值)后必需store(存储))。store(存储)后write(写入)。也就是做到了给一个变量赋值的时候一串关联指令直接把变量值写到主内存。就这样通过用的时候直接从主内存取，在赋值到直接写回主内存做到了内存可见性。o(╥﹏╥)o</p><p> <strong>read-load-use</strong> 和 <strong>assign-store-write</strong> 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次…o(╥﹏╥)o<br>但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i &#x3D; i + 1; i++;之类的，那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。《深入理解Java虚拟机》提到：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290032234.png" alt="po_diagram (1)"></p><p>JVM的字节码，i++分成三步，间隙期不同步非原子操作(i++)</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290036054.png" alt="po_diagram (2)"></p><h3 id="指令禁重排"><a href="#指令禁重排" class="headerlink" title="指令禁重排"></a>指令禁重排</h3><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>​&#x3D;&#x3D;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段&#x3D;&#x3D;，有时候会改变程序语句的先后顺序<br>不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序<br>注意⚠️：重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p><p>重排序的分类和执行流程</p><ol><li>编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</li><li>指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序： 由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li><li>数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</li></ol><p>案例 ：<br><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290042815.png" alt="image-20240529004156263"></p><p>存在数据依赖关系，禁止重排序&#x3D;&#x3D;&#x3D;&gt; 重排序发生，会导致程序运行结果不同。<br> 编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290050933.png" alt="image-20240529005028521"></p><h3 id="volatile的底层实现是通过内存屏障"><a href="#volatile的底层实现是通过内存屏障" class="headerlink" title="volatile的底层实现是通过内存屏障"></a>volatile的底层实现是通过内存屏障</h3><h4 id="volatile有关的禁止指令重排的行为"><a href="#volatile有关的禁止指令重排的行为" class="headerlink" title="volatile有关的禁止指令重排的行为"></a>volatile有关的禁止指令重排的行为</h4><ol><li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li><li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</li><li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</li></ol><h4 id="四大屏障的插入情况"><a href="#四大屏障的插入情况" class="headerlink" title="四大屏障的插入情况"></a>四大屏障的插入情况</h4><ol><li>在每一个volatile写操作前面插入一个StoreStore屏障，StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</li><li>在每一个volatile写操作后面插入一个StoreLoad屏障，StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序。</li><li>在每一个volatile读操作前面插入一个LoadLoad屏障，LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</li><li>在每一个volatile读操作后面插入一个LoadStore屏障，LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---i  =  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290058587.png" alt="image-20240529005803058"></p><h3 id="如何正确使用volatile"><a href="#如何正确使用volatile" class="headerlink" title="如何正确使用volatile"></a>如何正确使用volatile</h3><p>单一赋值可以，but含复合运算赋值不可以(i++之类)</p><p>volatile int a &#x3D; 10;  volatile boolean flag &#x3D; false;</p><p>1、状态标志，判断业务是否结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用：作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束 </span></span><br><span class="line"><span class="comment"> * 理由：状态标志并不依赖于程序内任何其他状态，且通常只有一种状态转换 </span></span><br><span class="line"><span class="comment"> * 例子：判断业务是否结束 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseVolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do something......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、开销较低的读，写锁策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseVolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用：当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销</span></span><br><span class="line"><span class="comment">     * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;   <span class="comment">//利用volatile保证读取操作的可见性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value++; <span class="comment">//利用synchronized保证复合操作的原子性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL双端锁的发布"><a href="#DCL双端锁的发布" class="headerlink" title="DCL双端锁的发布"></a>DCL双端锁的发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双重锁设计</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程环境下(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405290127295.png" alt="image-20240529012737397"></p><p>解决01:加volatile修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过volatile声明，实现线程安全的延迟初始化。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SafeDoubleCheckSingleton singleton;</span><br></pre></td></tr></table></figure><p>解决02:采用静态内部类的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在比较好的做法就是采用静态内部内的方式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonDemoHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonDemoHandler.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h2><p>​ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为&#x3D;&#x3D;每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。&#x3D;&#x3D;ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p><pre><code> 实现每一个线程都有自己专属的本地变量副本，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</code></pre><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302243032.png" alt="image-20240530224314824"></p><h2 id="api介绍"><a href="#api介绍" class="headerlink" title="api介绍"></a>api介绍</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>1、new 之后复写initiaValue()</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302305249.png" alt="image-20240530230508608"></p><p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p><p>2、ThreadLocal.withInitial(() - 0);</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302245537.png" alt="image-20240530224540542"></p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>​返回此线程局部变量的当前线程副本中的值。如果变量对当前线程没有值，则首先将其初始化为initialValue方法调用返回的值。返回值:线程本地当前线程的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>设置值。<code>threadLocal.set(value);</code></p><p>将此线程局部变量的当前线程副本设置为指定值。大多数子类不需要重写这个方法，只依赖于{@link initialValue}方法来设置线程局部变量的值。</p><p>@param value要存储在当前线程的这个线程本地副本中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>移除此线程局部变量的当前线程值。如果这个线程局部变量随后被当前线程{@linkplain get read}，它的值将通过调用它的{@link initialValue}方法重新初始化，除非当前线程在此期间将它的值设置为{@linkplain set set}。这可能导致在当前线程中多次调用{@code initialValue}方法。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302309010.png" alt="image-20240530230912717"></p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、每次使用日历控件都需要设置一次日期格式，刚入行的时候，经验不丰富。为了方便把sdf定义为一个静态变量，并且把它分装成了一个方法。后来其他同事相继调用，各种频繁调错。被测试痛批。</span></span><br><span class="line">    <span class="comment">//  源码：sdf中的日期格式是不同步的，推荐位每一个线程创建独立的格式实例。如果多个线程同时访问一个格式。则它必须保持外部同步。</span></span><br><span class="line">    <span class="comment">//  原因：SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。</span></span><br><span class="line">    <span class="comment">//  clear是线程不安全的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parse</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方案1:将SimpleDateFormat定义成局部变量。</span></span><br><span class="line">    <span class="comment">// 缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。</span></span><br><span class="line">    <span class="comment">// 线程少的时候可以考虑，如果线程多的话就不合适了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方案2   ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; sdfThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Date <span class="title function_">parseByThreadLocal</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> sdfThreadLocal.get().parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方案3 DateTimeFormatter 代替 SimpleDateFormat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，</span></span><br><span class="line"><span class="comment">    DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable</span></span><br><span class="line"><span class="comment">    thread-safe。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">DATE_TIME_FORMAT</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DATE_TIME_FORMAT.format(localDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">parseByDateTimeFormatter</span><span class="params">(String dateString)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateString, DATE_TIME_FORMAT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(ThreadLocalDateUtils.parse(&quot;2011-11-11 11:11:11&quot;));</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line"><span class="comment">                    System.out.println(sdf.parse(&quot;2011-11-11 11:11:11&quot;));</span></span><br><span class="line"><span class="comment">                    sdf = null;*/</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(ThreadLocalDateUtils.parse(<span class="string">&quot;2011-11-11 11:11:11&quot;</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//remove();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302347505.png" alt="image-20240530234737568"></p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405302352618.png" alt="Snipaste_2024-05-30_23-49-06"></p><h3 id="Thread、ThreadLocal、ThreadLocalMap-关系"><a href="#Thread、ThreadLocal、ThreadLocalMap-关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap 关系"></a>Thread、ThreadLocal、ThreadLocalMap 关系</h3><p>ThreadLocal源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment"> * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>说明：Thread里面有一个ThreadLocal</p><p>ThreadLocal和ThreadLocalMap：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310006877.png" alt="image-20240531000603742"></p><p>说明：ThreadLocal里面有一个ThreadLocalMap</p><p>ThreadLocalMap实际上是一个以ThreadLocal实例为key，任意对象为Value的Entry数组。当给你我们为Thread Local变量赋值的时候，实际上就是以当前的ThreadLocal为key,值为value的Entry往这个ThreadLocalMap中存放。</p><p>ThreadLocalMap源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：ThreadLocalMap中实际中的存储是用Entry，是弱引用</p><h2 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h2><h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p><h3 id="谁惹的祸？"><a href="#谁惹的祸？" class="headerlink" title="谁惹的祸？"></a>谁惹的祸？</h3><h4 id="强引用、软引用、弱引用、虚引用分别是什么？"><a href="#强引用、软引用、弱引用、虚引用分别是什么？" class="headerlink" title="强引用、软引用、弱引用、虚引用分别是什么？"></a>强引用、软引用、弱引用、虚引用分别是什么？</h4><p>ThreadLocalMap与WeakReference ，ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)，不过是经过了两层包装的ThreadLocal对象：<br>（1）第一层包装是使用 WeakReference&lt;&lt;ThreadLocal&lt;<?>> 将ThreadLocal对象变成一个弱引用的对象；（2）第二层包装是定义了一个专门的类 Entry 来扩展 WeakReference<<ThreadLocal<<?>&gt;：</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310018509.png" alt="image-20240531001810543"></p><h5 id="强引用-默认支持模式"><a href="#强引用-默认支持模式" class="headerlink" title="强引用(默认支持模式)"></a>强引用(默认支持模式)</h5><p>​&#x3D;&#x3D;当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收&#x3D;&#x3D;，死都不收。</p><p>​强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p><p>​对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();<span class="comment">//默认，强引用,死了都不放手</span></span><br><span class="line">    System.out.println(<span class="string">&quot;gc before: &quot;</span> + myObject);</span><br><span class="line">    myObject = <span class="literal">null</span>;</span><br><span class="line">    System.gc();<span class="comment">//手动挡的方式开启Gc回收。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;gc after: &quot;</span> + myObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p><p>对于只有软引用的对象来说，</p><pre><code> 当系统内存充足时它         不会     被回收， 当系统内存不足时它         会       被回收。</code></pre><p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">softReference</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());<span class="comment">//软引用</span></span><br><span class="line"><span class="comment">// 1、内存够用，不会回收</span></span><br><span class="line">    <span class="comment">/*内存够用</span></span><br><span class="line"><span class="comment">    System.out.println(&quot;gc before内存够用: &quot;+softReference);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    System.gc();//手动挡的方式开启Gc回收。</span></span><br><span class="line"><span class="comment">    try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    System.out.println(&quot;gc after内存够用: &quot;+softReference);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、内存不够用，回收</span></span><br><span class="line">    <span class="comment">//设置参数-Xms10m -Xmx10m</span></span><br><span class="line">    System.out.println(<span class="string">&quot;gc before: &quot;</span> + softReference);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span> + softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">weakReference</span><span class="params">()</span> &#123;</span><br><span class="line">    WeakReference&lt;MyObject&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;gc before: &quot;</span> + weakReference.get());</span><br><span class="line"></span><br><span class="line">    System.gc();<span class="comment">//手动挡的方式开启Gc回收。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;gc after: &quot;</span> + weakReference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有一个应用需要读取大量的本地图片:</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能,</li><li>如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。</li></ul><p>设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><p>Map&lt;String, SoftReference<Bitmap>&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference<Bitmap>&gt;();</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p> 虚引用需要java.lang.ref.PhantomReference类来实现。</p><p>顾名思义，就是&#x3D;&#x3D;形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。&#x3D;&#x3D;<br>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，<br>它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。</p><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。</p><p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作 。</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</p><h5 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h5><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310047366.png" alt="image-20240531004657979"></p><h5 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h5><p>每个Thread对象维护着一个ThreadLocalMap的引用<br>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储<br>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象<br>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象<br>ThreadLocal本身并不存储值，它只是自己作为一个key来让线程从ThreadLocalMap获取value，正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～</p><h3 id="为什么要用弱引用-不用如何？"><a href="#为什么要用弱引用-不用如何？" class="headerlink" title="为什么要用弱引用?不用如何？"></a>为什么要用弱引用?不用如何？</h3><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310053775.png" alt="image-20240531005313750"></p><h4 id="为什么源代码用弱引用？"><a href="#为什么源代码用弱引用？" class="headerlink" title="为什么源代码用弱引用？"></a>为什么源代码用弱引用？</h4><p>为什么源代码用弱引用?<br>当function01方法执行完毕后，栈帧销毁强引用 tl 也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象<br>若这个<strong>key</strong>引用是<strong>强引用</strong>，就会导致<strong>key</strong>指向的<strong>ThreadLocal</strong>对象及v指向的对象不能被<strong>gc</strong>回收，造成内存泄漏；<br>若这个<strong>key</strong>引用是<strong>弱引用</strong>就<strong>大概率</strong>会减少内存泄漏的问题(<strong>还有一个key为null的雷</strong>)。使用弱引用，就可以使<strong>ThreadLocal</strong>对象在方法执行完毕后顺利被回收且<strong>Entry</strong>的<strong>key引用指向为null。</strong></p><p>–下面这句话，我们后续聊，本节先忽略<br>此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。</p><p>1 当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl&#x3D;null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。…</p><h5 id="key为null的entry，原理解析"><a href="#key为null的entry，原理解析" class="headerlink" title="key为null的entry，原理解析"></a>key为null的entry，原理解析</h5><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链。</p><p>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug。</p><p><img src="https://qijian-1301807797.cos.ap-guangzhou.myqcloud.com/markdown/202405310058199.png" alt="image-20240531005758402"></p><p>set、get方法会去检查所有键为null的Entry对象</p><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>​从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ThreadLocal 并不解决线程间共享数据的问题</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li><li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li><li>每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li><li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</li><li>都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法</li></ol><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Future和Callable接口"><a href="#Future和Callable接口" class="headerlink" title="Future和Callable接口"></a>Future和Callable接口</h3><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>Callable接口中定义了需要有返回的任务需要实现的方法。比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzyy.study.test;<span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;    </span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            </span><br><span class="line">      System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            </span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">      &#125;            </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>+ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        </span><br><span class="line">      &#125;</span><br><span class="line">                                                    );       </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>);        </span><br><span class="line">    t1.start();        </span><br><span class="line">    <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)              //System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());        </span></span><br><span class="line">    <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候        System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get(1L,TimeUnit.SECONDS));        System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot; run... here&quot;);    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>Future实际采用FutureTask实现，该对象相当于是消费者和生产者的桥梁，消费者通过 FutureTask 存储任务的处理结果，更新任务的状态：未开始、正在处理、已完成等。</p><p>1、get()阻塞：一旦调用get()方法，不管是否计算完成都会导致阻塞，o(╥﹏╥)o</p><p>2、get(long timeout, TimeUnit unit)：只等待一段时间，过时不侯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="comment">//构建futureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="comment">//作为Runnable入参</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;task运行结果：&quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正在计算&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、isDone()轮询：轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果；如果想要异步获取结果,通常都会以轮询的方式去获取结果尽量不要阻塞；执行结束（完成&#x2F;取消&#x2F;异常）返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果线程结束了，则获取结果</span></span><br><span class="line">            <span class="keyword">if</span> (futureTask.isDone()) &#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java 基础 </category>
          
          <category> java 基础 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留言版</title>
      <link href="/2024/11/14/comment/"/>
      <url>/2024/11/14/comment/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/13/index/"/>
      <url>/2024/11/13/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>联合索引的基础</title>
      <link href="/2024/11/13/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/13/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>&#x3D;&#x3D;联合索引失效的场景？a,b,c 联合索引 b&#x3D;null, a&#x3D;xx and b&#x3D;xx or c&#x3D;xx 会生效吗？&#x3D;&#x3D;</strong></p><p>联合索引在 MySQL 中的使用可能会受到查询条件的影响，从而导致索引失效。了解联合索引失效的场景有助于优化数据库查询性能。</p><h3 id="联合索引的基础"><a href="#联合索引的基础" class="headerlink" title="联合索引的基础"></a>联合索引的基础</h3><p>假设有一个表 <code>my_table</code>，上面有一个联合索引 <code>idx_abc</code>，它包含列 <code>a, b, c</code>。该索引按照 <code>(a, b, c)</code> 的顺序存储。</p><h3 id="联合索引失效的常见场景"><a href="#联合索引失效的常见场景" class="headerlink" title="联合索引失效的常见场景"></a>联合索引失效的常见场景</h3><ol><li><p><strong>列顺序和查询条件</strong>：</p><ul><li>联合索引在使用时需要遵循索引列的顺序。如果查询中跳过了索引中的某一列，后面的列不会使用索引。</li><li>例如，如果只有 <code>a</code> 和 <code>b</code> 创建了索引，而查询中只使用了 <code>b</code> 列条件，索引将不会生效。</li></ul></li><li><p><strong>范围查询</strong>：</p><ul><li>在联合索引中，一旦有一列使用了范围查询（如 <code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>，<code>LIKE</code> 等），后面的列将不再使用索引。</li></ul></li><li><p><strong>NULL 判断</strong>：</p><ul><li>对于 <code>IS NULL</code> 和 <code>IS NOT NULL</code> 条件，索引的使用可能会有所不同，具体取决于索引类型和查询优化器的选择。</li></ul></li></ol><h3 id="具体问题分析"><a href="#具体问题分析" class="headerlink" title="具体问题分析"></a>具体问题分析</h3><p>对于查询 <code>b IS NULL</code> 和 <code>a = xx AND b = xx OR c = xx</code>，我们来分析是否会使用联合索引 <code>(a, b, c)</code>。</p><ol><li><p>**<code>b IS NULL</code>**：</p><ul><li>对于 <code>b IS NULL</code>，如果索引是 <code>(a, b, c)</code>，并且没有对 <code>a</code> 提供条件，那么在大多数情况下，这个查询不会使用到联合索引，特别是在传统的 B-Tree 索引中。</li></ul></li><li><p>**<code>a = xx AND b = xx OR c = xx</code>**：</p><ul><li>对于 <code>a = xx AND b = xx OR c = xx</code>，查询优化器会将其分为两个部分来处理：<ul><li><code>a = xx AND b = xx</code></li><li><code>c = xx</code></li></ul></li><li>这里有一个 <code>OR</code> 条件，MySQL 的查询优化器在遇到 <code>OR</code> 时，往往会放弃使用联合索引而改为全表扫描，特别是当 <code>OR</code> 的条件不能都使用到同一个索引时。</li><li>如果 <code>a = xx AND b = xx</code> 部分可以有效使用到 <code>(a, b, c)</code> 索引，但是 <code>c = xx</code> 不能单独使用这个索引，因此整体上可能会选择全表扫描。</li></ul></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li><p>**<code>b IS NULL</code>**：</p><ul><li>这个查询很可能不会使用联合索引 <code>(a, b, c)</code>，因为没有对索引的前导列 <code>a</code> 提供条件。</li></ul></li><li><p>**<code>a = xx AND b = xx OR c = xx</code>**：</p><ul><li>由于存在 <code>OR</code> 条件，并且 <code>c = xx</code> 不能利用 <code>(a, b, c)</code> 索引的前导列，因此查询优化器可能不会使用联合索引，而是选择全表扫描。</li></ul></li></ol><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><ol><li><p><strong>避免使用 <code>OR</code> 条件</strong>：</p><ul><li><p>尽量避免在查询中使用 <code>OR</code> 条件，可以通过 <code>UNION</code> 分开两个查询来优化，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> a <span class="operator">=</span> xx <span class="keyword">AND</span> b <span class="operator">=</span> xx)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> c <span class="operator">=</span> xx);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>索引覆盖</strong>：</p><ul><li>设计联合索引时，考虑查询的具体使用情况，确保最左前缀原则。</li></ul></li><li><p><strong>EXPLAIN 分析</strong>：</p><ul><li>使用 <code>EXPLAIN</code> 命令来分析查询计划，确保索引的使用情况。</li></ul></li></ol><p>通过了解这些原则，可以更好地设计和优化 MySQL 数据库中的联合索引，提高查询性能。</p>]]></content>
      
      
      <categories>
          
          <category> mysql 知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
